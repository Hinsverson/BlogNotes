# 汇编
#汇编

![](%E6%B1%87%E7%BC%96/D8468F85-7714-44F4-9B18-C83560F52161.png)

![](%E6%B1%87%E7%BC%96/48C0C2B5-964A-4908-B739-0392ABCD1876.png)
CPU把内存中的数据读取出来存入寄存器执行运算，再将结果送回内存中。

![](%E6%B1%87%E7%BC%96/A4D24046-E906-4A94-B373-125BC1CBC582.png)

# 汇编核心-寄存器
存储CPU计算的数据， x64一个寄存器存8位的数据。

![](%E6%B1%87%E7%BC%96/5984A6E9-67C3-46CD-8396-5CFC3EB51B3C.png)

![](%E6%B1%87%E7%BC%96/EA7A9CD4-56D7-43DA-A9DF-B8A9967C18C6.png)
![](%E6%B1%87%E7%BC%96/4F4FD195-5293-4435-81BF-EAA18E35D6B1.png)
64位汇编完全兼容32位，所以在64位汇编里也能看到32位对应的通用寄存器，原理只是在64位汇编的前32位用做存储。

RAX（64）EAX（32）AX（16）AH和AL（8）位。
所以汇编里修改RAX寄存器的内容会对，也会对EAX和AX进行影响

## C++里使用汇编
![](%E6%B1%87%E7%BC%96/5826D65B-3D91-42DA-AEC8-B83F46BF4177.png)

# 理解汇编指令

![](%E6%B1%87%E7%BC%96/3462FA2A-1AB4-4949-B17E-B40CE13E0221.png)
![](%E6%B1%87%E7%BC%96/B403BF98-3469-49A9-9F3C-7DA2EB5C7735.png)

![](%E6%B1%87%E7%BC%96/071F4797-CBC8-49DD-A58C-924261397AF6.png)
dword为2倍word（一个字言2个字节），共4个字节，决定存取单位。

数据的写入和读取是从低到高还是从高到低（也就是说00000011是存在1128h这个字节还是112Bh这个字节由CPU的大小端模式决定，小端从高位往低位读写，大端反过来）

> 小端模式，高高低低（高字节放高地址，低字节放低地址）  
>   
> 变量的地址值，其实是存储在内存中所占字节内存地址最小的那个。  


## 例子1
![](%E6%B1%87%E7%BC%96/A8B46A4D-FE64-434E-A500-E70526B5E719.png)

`mov dword ptr [ebp-8], 1`
把1存储在从地址ebp-8开始从低往高地址读4个字节的内存区域。

`mov dword ptr [ebp-14h], 3`
把12储在从地址ebp—14h开始从低往高地址读4个字节的内存区域。

`mov eax, dword ptr [ebp-8]`
从ebp-8地址开始4个字节的数据读取出来存储到eax通用寄存器中。

`add eax, dword ptr [ebp-14h]`
从ebp-14h地址开始4个字节的数据读取出来与eax中存储的值相加后再存储到eax通用寄存器中。

`mov dword ptr [ebp-20h], eax`
把eax的值取出来存储在ebp-14h地址所在的内存区域中。

> [ebp-14h]内可以理解为地址运算，一个固定地址减去14h个字节单位后的地址  

## 通过指针间接修改变量的汇编过程
`lea eax, [1128h]`  `mov eax, [1128h]`  
把地址1128h值存储到eax通用寄存器中。

![](%E6%B1%87%E7%BC%96/74D9EE44-E8CD-4029-BAE7-00F8BCF521A9.png)

解释
![](%E6%B1%87%E7%BC%96/CC80041F-7DB2-4672-9E60-6C267F59D4A7.png)








