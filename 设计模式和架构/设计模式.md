# 设计模式
#iOS知识点/设计模式和架构

一种编程思想，就是保证可用性的同时让代码更容易理解，逻辑结构更加清晰，在不同的场景下解决不同的问题。

# IOS系统中常见设计模式
1. MVC：把View和数据通过controller联系起来（典型的就是TableView的系统封装）
2. 委托模式：灵活的决定哪些代码由谁运行（协议-代理）
3. 通知观察者模式：允许代码监视在App内发生的事情（KVO、Notifaction）
4. Target-Action：消息处理模式

# 设计原则
![](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0E85C0FC-15B7-4A30-B780-7853D20FC023.png)

1. 开闭原则：对扩展开放，对修改关闭。
2. 里氏替换原则：任何基类可以出现的地方，子类一定可以出现，子类能够替换任何其超类，具有is-A关系。
3. 单一职责原则：类本身的功能应该高内聚、低耦合，职责明确。
4. 接口隔离：类对外的接口应该高内聚，低耦合（delegate、datasource分工不同）
5. 依赖倒置：依赖于抽象的借口，不要依赖于具体实现，面向接口编程。
6. 迪米特法则：一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，

# Swift面向对象和面向协议的理解
1. 面向对象是is-A的继承关系，面向协议是更灵活的组合关系。
2. 通常面向协议比面向对象更灵活，大部分场景可以替换。
3. 继承的场景适用于直接获取父类行为而不修改破坏的情况，如果在继承中有重写发生时为了保证里氏替换原则，那么就要考虑面是否采用协议的方式来组合实现。

# 常见设计模式总结
[23个经典设计模式的Swift实现 - 掘金](https://juejin.im/post/6844903576301469704)
[Design-Patterns-In-Swift/README-CN.md at master · ochococo/Design-Patterns-In-Swift · GitHub](https://github.com/ochococo/Design-Patterns-In-Swift/blob/master/README-CN.md)

## 创建型模式
1. ::Factory 工厂模式::：为具备继承关系的类型的构造提供一种统一的构造方式，Factory通过提供抽象方法，把product的构造工作放在具体的工厂类去，Factory代替了Client对具体Product的依赖。
	* 适用于解决单一基类的构造问题（一条派生线）。
2. ::Abstract Factory 抽象工厂::：在工厂模式之上的一种递进，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
	 * 适用于解决多个相关基类的构造问题（多条派生线）。
3. ::Builder 建造者模式::：把对象内部的组装工作抽离出去，通过不同的Builder来构造不同的对象，从而产生出不同属性或行为的对象，对比工厂模式是一个类(工厂)创建另一个类(产品)，而建造者是一个类(产品)自身的属性(组件)构造过程。
	* 适用于对复杂对象的构造。
4. ::Prototype 原型模式::：通过在任何时候复制一个已经存在的实例的属性来返回新的实例继续使用，而不是新建实例。
5. ::Singleton 单例模式::：保证一个类仅有一个实例，并提供一个访问它的全局访问点。整个系统只拥有一个的全局对象从而唯一协调系统整体的行为。单例其实就是变种的原型模式，只不过原型每次返回的是一个拷贝。
	* 过度使用的危害极大，在单例实现中你无从知道调用从何而来，这种goto一般的存在会变成维护的噩梦。

## 结构型模式（Structural）
1. ::Adapter 适配器模式::：将一个类的接口转换成另外一个希望可用的接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
	* OC和Swift混编时经常这么干进行相互参数的转化。
2. ::Bridge 桥接模式::：桥接模式就是这么一座桥，它矗立在具体和抽象之间，当你调用的时候只看到了抽象，但是它内部实现时“桥接”到了具体。通过以组合（新的抽象类中内部持有）而不是继承的方式把具备相同能力的对象组合在一起，从而将抽象部分（新的抽象类的抽象能力）与实现部分（具备相同能力的对象各自有具体的能力实现）分离，使它们都可以独立的变化，达到一种解耦的目的。
	* 适配器的关注点是如何让两个不兼容的类对接， 而桥接模式关注点是解耦。
3. ::Composite 组合模式::：将对象组合成树形结构以表示‘部分-整体’的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
	* 适用于层次化的树形结构，比如二叉树中每个节点都有相同行为，当非叶子节点又包含其他节点。
4. ::Decorator 装饰者模式::：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更为灵活，因为它是给某个对象而不是整个类添加一些功能。
	* 当需要零散的不断给“主菜加点佐料”的时候，并且这些佐料会经常变化，那么这个模式就可以有效的解决排列组合产生的类爆炸。

## 行为型模式
1. ::Chain of responsibility 责任链模式::：包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。
	* RxSwift的对序列的操作就是一种责任链模式的设计思想。
	* UIResponder的实现也是这种模式。
2. ::Iterator 迭代器模式::：让用户通过特定的接口巡访容器中的每一个元素而不用了解底层的实现。
	* Swift中集合类型的遍历就是一种典型的实现场景。
3. ::Mediator 中介模式::：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。
	* 对于通信关系复杂的系统有很好的解耦效果。
4. ::Observer 观察者模式::：一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。
	* KVO的实现原理
5. ::State 状态模式::：对象的行为是基于它的内部状态而改变的。
	* 一种封装的思想，对象的行为根据内部的状态变化，而外部不需要关系变化逻辑。
6. ::Strategy 策略模式::：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。
	* 解决一个本来稳定的继承树当遇到需求变化时的狼狈情况。他把变化的几种情况分门别类的封装好，然后把自己变化的部分隔离成一个接口实例，让子类继承后来做选择题。