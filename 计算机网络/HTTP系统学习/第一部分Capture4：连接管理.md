# 第一部分Capture4：连接管理
#计算机网络/HTTP

* HTTP 是如何使用 TCP 连接的
* TCP 连接的时延、瓶颈以及存在的障碍
* HTTP 的优化，包括并行连接、keep-alive(持久连接)和管道化连接
* 管理连接时应该以及不应该做的事情。

4.1 TCP连接
TCP/IP 是全球计算机及网络 设备都在使用的一种常用的分组交换网络分层协议集。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序 。
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/1E295E79-4738-4662-95A9-A95EAD5CE50F.png)

4.1.1 TCP是可靠的数据传输协议
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/13BD600C-69ED-4107-BE1F-0639B47E1A59.png)
本质：TCP保证可靠是通过重发机制（没有收到消息到达反馈则继续重发）

4.1.2 TCP流是分段的、由IP分组传送 
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/A253261F-C2EF-4DC2-AEA6-4FF59B7FE7A7.png)
HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中 ，通过因特网进行传输。

4.1.3 TCP连接的识别和区分 

TCP 连接是通过 4 个值来识别的和区分的。
< 源 IP 地址、源端口号、目的 IP 地址、目的端口号 >
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/C05380DF-759F-4FEC-A476-47B90273A4A1.png)

4.1.4 TCP套接字编程 
操作系统提供了一些操纵其 TCP 连接的API接口，这些接口被称为套接字。
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/CD6338DB-5186-4C75-833C-DE92094413FB.png)

TCP客户端和服务器通过套接字通信过程的伪代码实现
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/72B059EA-4FE9-460D-A729-5F01360D61ED.png)

4.2 TCP性能优化考虑 
HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能 。更好地理解 HTTP 的连接优化特性，就能设计实现一些更高性能的 HTTP 应用程序。 

4.2.1 HTTP事务的时延

![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/BFC3AA6E-0227-4935-BF16-6FE692F1A4D3.png)

> 除非客户端或服务器超载，或正在处理复杂的动态资源，否则 HTTP 时 延就是由 TCP 网络时延构成的。因为与建立 TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能 是很短的。  
 
1. 建立TCP连接前，在首次根据URI确定目标主机IP地址和端口号时，DNS 解析系统将 URI 中的主机名转换成一个 IP 地址可能要花费数十秒的时间。（大多数浏览器第一次访问后“缓存”记录了 IP 地址，查询就可以立即完成 ）
2. 建立TCP连接时，客户端向服务器发送TCP 连接请求，等待服务器回送一个请求接受应答。每条新的 TCP 连接都会有连接建立时延，这个值通常最多只有一两秒钟。
3. 建立连接后，因特网传输请求报文，以及服务器处理请求报文都需要时间。 
4. web服务器回送 HTTP 响应，这也需要花费时间 。

4.2.2 常见的 TCP 相关时延 

* TCP 连接建立握手; 
* TCP 慢启动拥塞控制; 
* 数据聚集的 Nagle 算法; 
* 用于捎带确认的 TCP 延迟确认算法; 
* TIME_W AIT 时延和端口耗尽。 

4.3 HTTP连接的处理
从 HTTP 的 Connection 首部开始介绍，这是 HTTP 连接管理中一个很容易被误解，但又很重要的部分。

4.3.1 Connection首部
HTTP 允许在客户端和最终的源端服务器之间存在一串 HTTP 中间实体(代理、高 速缓存等)。可以从客户端开始，逐跳地将 HTTP 报文经过这些中间设备，转发到源端服务器上去(或者进行反向传输)。通过Connection首部允许发送端指定与连接有关的一些选项。

![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/401199B5-B0CD-4E79-8043-7913BB973E93.png)
这里假想的选项是指“假定的任意标签”，是发送报文方自己指定，而非标准的首部字段。


connection的3种不同标签
* HTTP 首部字段名（转发前列出的首部字段会被删除）

> 如果连接标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息。在将报文转发出去之前，必须删除 Connection 首部列出的所有首部字段。  
> 可能还会有少量没 有作为 Connection 首部值列出，但一定不能被代理转发的逐跳首部。其中包括 Prxoy-Authenticate、Proxy-Connection、Transfer-Encoding 和 Upgrade等。   
> 由于 Connection 首部可以防止无意中对报文首部的转发，因此将逐跳首部名放入Connection 首部被称为“对首部的保护”。   
 
* 自定义任意标签值（用于描述此连接的非标准选项）
* 值 close（说明操作完成之后需关闭这条持久连接）

4.3.2 串行事务处理时延
如果只对连接进行简单的串行管理，TCP 的性能时延可能会叠加起来 。
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/F1B59F6E-0D42-449A-97FF-2A420C52A830.png)

解决方案
* 并行连接
通过多条 TCP 连接发起并发的 HTTP 请求。 
* 持久连接
重用 TCP 连接，以消除连接及关闭时延。 
* 管道化连接
通过共享的 TCP 连接发起并发的 HTTP 请求。 

4.4 并行连接 
优点
同时请求多个资源对象，可能提高加载速度
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/964F5961-E8D3-4DC9-8723-98136C04F0C8.png)

缺点
* 每个事务都会打开 / 关闭一条新的连接，会耗费时间和带宽。 
* 由于TCP 慢启动特性的存在，每条新连接的性能都会有所降低。 
* 可打开的并行连接数量实际上是有限的。 

> 一般浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小 的值(通常是 4 个)。同时服务器可以随意关闭来自特定客户端的超量连接。   

4.5 持久连接 
优点
* 持久连接降低了时延和连接建立的开销。
* 减少了打开连接的潜在数量 。

缺点
管理时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。 

一般通过持久连接与并行连接配合使用，提高性能

4.5.1 Keep-Alive 
如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部 (参见图 4-14)。如果响应中没有 Connection: Keep-Alive 首部，客户端就认为 服务器不支持 keep-alive，会在发回响应报文之后关闭连接。 
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/E6E71E1F-2C6F-4AA6-A636-C8C7DAF42F60.png)

报文示例
```
Connection: Keep-Alive 
Keep-Alive: max=5, timeout=120 
```
说明服务器最多还会为 另外 5 个事务保持连接的打开状态，或者将打开状态保持到连接空闲了 2 分钟之后 

4.5.2 persistent connection 
TTP/1.1 逐渐停止了对 keep-alive 连接的支持，用一种名为持久连接(persistent connection)的改进型设计取代了它， 默认情况下是激活的 。


> 只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主体部分的长度都和相应的 Content-Length 一致，或者是用分块传输编码方式编码的——连接才能持久保持。   

4.6 管道化连接 
HTTP/1.1 允许在持久连接上可选地使用请求管道。这是相对于 keep-alive 连接的又一性能优化。在响应到达之前，可以将多条请求放入队列（相当于在多个管道中异步执行） 
![](%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86Capture4%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/DB87AEA6-D184-42C6-B6D4-3C360758DDC0.png)

4.7 HTTP连接的关闭 

所有 HTTP 客户端、服务器或代理都可以在任意时刻关闭一条 TCP 传输连接。通常会在一条报文结束时关闭连接。 

*HTTP 关闭时如何保证数据可靠*
每条 HTTP 响应都应该有精确的 Content-Length 首部，用以描述响应主体的尺寸。 客户端或代理收到一条随连接关闭而结束的 HTTP 响应，且实际传输的实体长度与 Content-Length 并不匹配(或没有 Content-Length)时，接收端就应该质疑长度的正确性。 

如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是幂 等的。实现者们可以认为 GET、HEAD、PUT、DELETE、TRACE 和 OPTIONS 方 法都共享这一特性。 

客户端不应该以管道化方式传送非幂等请求(比如 POST)。 否则，传输连接的过早终止就会造成一些不确定的后果。要发送一条非幂等请求， 就需要等待来自前一条请求的响应状态。 

应用程序可以关闭 TCP 输入和输出信道中的任意一个，或者将两者都关闭了。套 接字调用 close() 会将 TCP 连接的输入和输出信道都关闭了。这被称作“完全关 闭”，如图 4-20a 所示。还可以用套接字调用 shutdown() 单独关闭输入或输出信 道。这被称为“半关闭”， 






 




