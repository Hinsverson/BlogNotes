# Socket 相关
#计算机网络/TCPIP 

<a href='Socket%20%E7%9B%B8%E5%85%B3/TCPIP%E9%83%A8%E5%88%86-socket.pdf'>TCPIP部分-socket.pdf</a>

# 重要理解
[Linux Socket编程（不限Linux） - 吴秦 - 博客园](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)
1. 将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序（大端），而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。
2. server创建socket()、bind()端口号之后就会调用listen()来监听这个socket，listen函数将socket变为被动类型的，等待客户的连接请求。
3. client依次调用socket()、connect()之后就向server发送了一个连接请求。
4. server监听到这个请求之后，就会调用accept()函数取接收请求。

accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字。
accept函数返回的是已连接的socket描述字，一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。

## 三次握手
当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态。
服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态。
客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认。
服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。

## 四次挥手
某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M。
另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据。
一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N。
接收到这个FIN的源发送端TCP对它进行确认。

## Socket缓冲区的理解
![](Socket%20%E7%9B%B8%E5%85%B3/31AFD2A6-0A40-4921-9465-FC5715820348.png)
每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。
write()并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。
TCP协议独立于 write()函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。
read()函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。

## Socket中的默认阻塞模式
对于TCP套接字使用 write()发送数据时：
1. 首先会检查输出缓冲区，如果输出缓冲区的可用空间长度小于要写入的数据，那么 write()会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()函数继续写入数据。
2. 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()也会被阻塞，直到数据发送完毕缓冲区解锁，write()才会被唤醒。

对于TCP套接字使用 read()读取数据时：
1. 首先会检查输入缓冲区，如果输入缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。
2. 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()函数再次读取。

## Socket中关闭连接的方式
close() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字。
shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。

调用 close()关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。

> 默认情况下，close()会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()将丢失输出缓冲区中的数据，而调用 shutdown() 不会。  

[基于UDP的服务器端和客户端](http://c.biancheng.net/view/2359.html)

操作系统提供的一组用于网络编程的封装接口，主要用于不同计算机进程间的网络通信，也可以理解为位于应用层和传输层间的一个抽象层，应用层通过它来和运输、网络层交互，完成连接通信的目的。
![](Socket%20%E7%9B%B8%E5%85%B3/D2A743C9-3CCC-47DE-A6BA-FA19AC06558A.png)

# Socket 的类型
## 流格式套接字（SOCK_STREAM）
基于TCP协议实现的一种可靠的、双向的通信数据流。
1. 数据在传输过程中不会消失（可靠）
2. 数据是按照顺序传输的（按顺）
3. 数据的发送和接收不是同步的（收发次数不一）

## 数据报格式套接字（SOCK_DGRAM）
基于UDP协议实现的一种不可靠的、不按顺序传递的、以追求速度为目的的套接字。
1. 强调快速传输而非传输顺序（快速）
2. 传输的数据可能丢失也可能损毁（不可靠）
3. 限制每次传输的数据大小（大小限制）
4. 数据的发送和接收是同步的（收发次数相同）

> 无连接套接字传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险；  
> 有连接套接字非常可靠，万无一失，但是传输效率低，耗费资源多。  

# 面向连接和无连接的套接字的区别
* 无连接套接字传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险；
* 有连接套接字非常可靠，万无一失，但是传输效率低，耗费资源多。

## 无连接的套接字
![](Socket%20%E7%9B%B8%E5%85%B3/88AC9B4D-69F4-4A6C-9436-17823351DEA2.png)
对于无连接的套接字，每个数据包可以选择不同的路径。遵循的是「尽最大努力交付」的原则，就是尽力而为，实在做不到了也没办法。每个数据包之间都是独立的，各走各的路，谁也不影响谁，除了迷路的或者发生意外的数据包，最后都能到达 H6。但是，到达的顺序是不确定的。

## 面向连接的套接字
![](Socket%20%E7%9B%B8%E5%85%B3/3A14348A-A9B5-432E-A890-DCFAA197A766.png)
面向连接的套接字在正式通信之前要先确定一条路径，没有特殊情况的话，以后就固定地使用这条路径来传递数据包了。

> 1.数据包的传输路径是路由器根据算法来计算出来的，算法会考虑很多因素，比如网络的拥堵状况、下一个路由器是否忙碌等。  
> 2.无连接套接字遵循的是「尽最大努力交付」的原则，就是尽力而为，实在做不到了也没办法。无连接套接字提供的没有质量保证的服务。  
> 3.面向连接为套接字为每一个数据包分配一个 ID序列号，接收端接收到数据包以后，再给发送端返回一个数据包，告诉发送端我接收到了 ID序列号 为 xxx 的数据包。  

# 网络通信中确认身份信息的三要素
## IP地址
在因特网上进行通信时，必须要知道对方的 IP 地址。实际上数据包中已经附带了 IP 地址，把数据包发送给路由器以后，路由器会根据 IP 地址找到对方的地里位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快就会找到目标计算机。

> 一台计算机可以拥有一个独立的 IP 地址，一个局域网也可以拥有一个独立的 IP 地址（对外就好像只有一台计算机）。对于目前广泛使用 IPv4 地址，它的资源是非常有限的，一台计算机一个 IP 地址是不现实的，往往是一个局域网才拥有一个 IP 地址。  

## MAC地址
真正能唯一标识一台计算机的是 MAC 地址，每个网卡的 MAC 地址在全世界都是独一无二的，计算机出厂时，MAC 地址已经被写死到网卡里面了（当然通过某些“奇巧淫技”也是可以修改的）。局域网中的路由器/交换机会记录每台计算机的 MAC 地址。

数据包中除了会附带对方的 IP 地址，还会附带对方的 MAC 地址，当数据包达到局域网以后，路由器/交换机会根据数据包中的 MAC 地址找到对应的计算机，然后把数据包转交给它，这样就完成了数据的传递。

## 端口号
有了 IP 地址和 MAC 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web 服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25。

# 套接字的使用
1. socket()函数传入地址族、套接字类型、传输协议创建套接字。
```
int socket(int af, int type, int protocol);
```
2. bind() 函数将套接字与特定的 IP 地址和端口绑定起来。
```
int bind(int sock, struct sockaddr *addr, socklen_t addrlen); 
```
3. connect() 函数建立连接。
```
int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen);
```
4. listen() 函数让套接字进入被动监听状态，有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。
```
int listen(int sock, int backlog); 
```
5. 当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求，它返回一个新的套接字来和客户端通信。
```
int accept(int sock, *struct* sockaddr *addr, socklen_t *addrlen)
```

