# TCP 连接建立和终止
#计算机网络/TCPIP

<a href='TCPIP%E9%83%A8%E5%88%86-%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2.pdf'>TCPIP部分-建立和终止.pdf</a>
[《TCP/IP详解 卷1:协议》 读书笔记 第十八章 TCP连接的建立与终止_jiange_zh的博客-CSDN博客_tcp/ip详解 tcp连接的建立与终止](https://blog.csdn.net/jiange_zh/article/details/50371118)

![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/60E8DCF8-D450-4997-AA37-030578E0C3D7.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/B3B661B3-5BF2-43AE-B9A9-793F4E19055B.png)
TCP的连接断开是2次FIN交换，4次握手其实感觉不准确，因为很有可能不是4个包，可能是3个包。

# TCP连接过程中的状态变化
<a href='TCPIP%E9%83%A8%E5%88%86-TCP%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB.pdf'>TCPIP部分-TCP状态迁移.pdf</a>
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/20151221120636233.jpg)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/20151221120655594.jpg)

## FIN_WAIT_2状态
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/A46BBC6E-428B-4F50-BF57-5D6788A0C4CE.png)
这是在关闭连接时的状态。在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于FIN_WAIT_2状态，而服务器则一直处于WAIT_CLOSE状态，而直到应用层来决定关闭这个状态。

## TIME_WAIT 状态
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/4A0C731A-A205-4D61-8780-8C18A624BC60.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/2F76E8E5-48FC-46E8-9275-3878987E4D99.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/8143695A-A612-4292-809A-CEFDF80AE7A6.png)
**TIME_WAIT 状态后为什么需要2MSL等待时间？**
是为防止最后一次握手的数据报没有传送到对方那里而准备的（注意这不是四次挥手，而是第四次挥手的保险状态）

MSL是任何报文段被丢弃前在网络内的最长时间。
  
注意：由于插口的2MSL状态（插口是IP和端口对的意思，socket），使得应用程序在2MSL时间内是无法再次使用同一个插口的，对于客户程序还好一些，但是对于服务程序，例如httpd，它总是要使用同一个端口来进行服务，而在2MSL时间内，启动httpd就会出现错误（插口被使用）。为了避免这个错误，服务器给出了一个平静时间的概念，这是说在2MSL时间内，虽然可以重新启动服务器，但是这个服务器还是要平静的等待2MSL时间的过去才能进行下一次连接，一般服务器重新启动时间都大于这个平静时间。

# 三次握手连接建立
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/12635D96-1F7A-482A-B768-CE258F553998.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/3FA867DA-281E-4227-A287-7433E574E3E4.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/48C66797-0616-4D2D-9822-556B26FB3B38.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/3F8EDE88-5985-4EEE-846E-F495536664C4.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/6483C28C-4F83-47C0-9B23-65F0B2245D9D.png)

# 2次FIN交换断开建立
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/8DBBB1F5-52C4-49D2-A65A-2E5721CD7AE8.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/4B9497BD-99CA-4B90-A763-88DAEFB92292.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/9204988B-9B5B-4F1B-AFFE-0BE1B2B89DC7.png)

# TCP连接超时的情况
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/4FADD083-B7DE-4726-9B28-AD8FAC8BAFEF.png)
一般第一个SYN超时超时后，第二个

# TCP连接的半关闭
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/995A5D52-16F7-445D-90F2-55FD93E88977.png)
关闭时是单向，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
（3） 服务器关闭客户端的连接，发送一个FIN给客户端。
（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。

# TCP中的RST异常终止复位连接
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/2B92CFEB-B004-4193-B837-3F43E37630D3.png)
RST：TCP首部中标志比特之一，表示重置连接、复位连接。

## RST常见场景：
1.到不存在的端口的连接请求
产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在监听。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息，而TCP则使用复位。

2.异常终止一个连接
终止一个连接的正常方式是一方发送FIN，但也有可能发送一个复位报文段而不是FIN来中途释放一个连接。有时称这为异常释放（abortive release）。
异常终止优点
马上丢弃任何待发数据并立即发送复位报文段。
区分是异常关闭的话会立即反应到应用层，所以应用程序使用的API必须提供产生异常关闭而不是正常关闭的手段。

3.检测半打开连接
如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开（Half-Open）的。任何一端的主机异常都可能导致发生这种情况）。半打开连接的另一个常见原因是当服务器主机突然掉电而不是正常的结束服务应用程序后再关机，服务器主机重启后，从客户向服务器发送另一行字符。由于服务器的TCP已经重新启动，它将丢失复位前连接的所有信息，因此它不知道数据报文段中提到的连接。TCP的处理原则是接收方以复位作为应答。

# TCP连接的同时打开和同时关闭
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/A5AE868D-0CB5-46EF-A1F6-29D96A178390.png)
![](TCP%20%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/C58E6C3B-F9BB-4F06-994E-3321F3535CC9.png)
同时打开和同时关闭则是两种特殊的TCP状态，指连接双方同时执行主动打开或主动关闭，发生的概率很小。

# TCP保活定时器
如果T C P连接的双方都没有向对方发送数据，则在两个T C P模块之间不交换任何信息。这意味着我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。

该情况容易出现半打开连接，即连接正常建立后，一方突然崩溃，而另一方无法得知。

保活并不是T C P规范中的一部分，许多人认为如果需要，这个功能不应该在 T C P中提供，而应该由应用程序来完成。

保活功能就是试图在服务器端检测到这种半开放的连接，释放资源，根据需要，通信双方都可以使用保活选项，以启动保活定时器。

如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段（我们将在随后的例子中看到这个探查报文段看起来像什么）。客户主机必须处于以下 4个状态之一。

(1)    客户主机依然正常运行，并从服务器可达。客户的 T C P响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来 2小时再复位。

(2)    客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的 T C P都没有响应。服务器将不能够收到对探查的响应，并在 7 5秒后超时。服务器总共发送 1 0个这样的探查，每个间隔 7 5秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。

(3)    客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。

(4)    客户主机正常运行，但是从服务器不可达。这与状态 2相同，因为T C P不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。

**注意**
对于一条TCP连接，如果一个中间设备给发送方回复了远端主机不可达，那么发送方会忽略掉该报文，认为网络只是暂时的不可达，而不是将TCP连接关闭。
如果是对于目标主机发来的主机不可达或端口不可达的处理，TCP会关闭该连接。



