# 传输层
#计算机网络/哈工大自顶向下


目标参考
![](%E4%BC%A0%E8%BE%93%E5%B1%82/55E1094B-7E26-4241-A6BE-FE0ADE0DFBA1.png)

# 传输层概述
## 对传输层核心功能的理解？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/0301ECC2-EB7B-40EC-8DAF-5BD609B852AD.png)

## 传输层和网络层的不同点对比？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/FB0AD7A5-ED77-4F9E-BA2E-AADA1E5D6655.png)

# 多路复用和多路分用
## 对多路复用/分用的理解，为什么是传输层必要功能？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/37437473-E547-4422-8E3F-9E09F2782EC7.png)
因为传输层是为不同应用进程间提供逻辑通信服务的，一台主机可能有多个应用进程，所以必须进行多路复用和分用。

## 无连接的多路分用？用什么信息标识socket？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/5C8F6C90-F357-45DA-BE0B-9624373AE410.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/B860DC0A-50A1-4FEF-B0CB-56A951066C02.png)

## 有连接的多路分用？用什么信息标识socket？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/667609B8-0EEE-4D00-96F9-5513BF49F49C.png)
因为TCP通信是1对1的（从socket上讲），所以用源端口号区分和同一台主机链接的不同socket。

### 多线程web服务器多路分用原理
![](%E4%BC%A0%E8%BE%93%E5%B1%82/7259E6C9-B6A7-4500-ACBB-7D5D9FDABC3F.png)
异同进程创建多个线程为多个TCP连接提供不同服务。 

# 无连接的UDP传输协议
## UDP主要功能理解？特点？为什么需要UDP
![](%E4%BC%A0%E8%BE%93%E5%B1%82/BBCE26A7-D389-4134-B1C4-89833530A81D.png)
UDP相当于把IP层进行简单的包装，只实现了必要的多路分/复用功能和简单的 错误校验，因为IP层本身就是不可靠的，所以UDP同样不可靠（如果采用UDP而应用层还需要可靠的传输，则要在应用层自己实现）。

特点就是无连接和不可靠。

为什么需要UDP？
不需要连接，实现简单不用维护连接状态，头部开销少，能会更好的控制发送时间和速率（因为没有拥塞控制）

## 报文结构
![](%E4%BC%A0%E8%BE%93%E5%B1%82/B53CF6F4-38CD-432A-B73F-B1B2FB648341.png)

## 校验和
![](%E4%BC%A0%E8%BE%93%E5%B1%82/3E1B72A1-4BF6-4BD6-ACEE-CC88FDD3C6D9.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/C9DD6A5E-8D04-4F52-BA0A-BE3C695852EE.png)
每16位相加，进位再加，再取反。

# 可靠的网络数据传输
## 可靠数据传输的整体理解？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/E6D21D95-9D7F-4FEA-BFB6-D735D09E076E.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/9B8607DD-4FAF-4D12-94E0-801A98606186.png)
从应用层的视角看是可靠的数据收发，并且收发都是单向的，由于下层传输信道的不可靠性，传输层协议和下层通信是一个反复的过程。

## 可靠数据传输协议的基本设计
![](%E4%BC%A0%E8%BE%93%E5%B1%82/7DB38F4F-8186-43D6-BEF7-E01F87D93AA7.png)

### 1.在可靠信道上进行可靠数据传输（理想情况）
![](%E4%BC%A0%E8%BE%93%E5%B1%82/994CAC45-CE7D-49CF-80C7-A1D572078A49.png)
收发都只需用一个状态刻画，发送方等待上层调用send，然后进行数据发送后又重新回到等待调用状态。

### 2.在可能产生位错误信道上进行可靠数据传输
![](%E4%BC%A0%E8%BE%93%E5%B1%82/822FDBB9-D08B-4CBC-A225-F38A5B294EB8.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/5F3FE4E9-D09E-4FE3-8250-6DB1020C25FD.png)
引入差错检测、消息确认和重传机制。
![](%E4%BC%A0%E8%BE%93%E5%B1%82/FDD0E860-A1B2-4C1C-8EB4-6F0C5396950C.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/20DB7C5C-434F-48F7-B726-9952A4133EBD.png)
引用序列号解决重复问题

![](%E4%BC%A0%E8%BE%93%E5%B1%82/379FB153-4C4B-4645-A1ED-2BA01D77101C.png)
 取消NAK，把序列号加入到ACK中。

### 3.在可能产生位错误或者分组丢失的信道上进行可靠数据传输
![](%E4%BC%A0%E8%BE%93%E5%B1%82/E6D1E2B2-7383-4CF7-9FBB-9D2697118565.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/5425AB84-9561-4C5F-8B22-71E1237784C8.png)
引入计时器，通过超时重传来解决可能的丢失问题。

### RDT3.0的性能问题，为什么？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/D401E765-FE99-4FC6-A5EF-1E0C54C85566.png)
产生性能差的原因就是因为平等，发一个等待再发一个。

## 用流水线机制提高RDT性能
![](%E4%BC%A0%E8%BE%93%E5%B1%82/E336B513-010D-41F0-9558-32D4890B916A.png)

### 对滑动窗口协议的理解（一种流水线机制）
![](%E4%BC%A0%E8%BE%93%E5%B1%82/E6C74913-93E6-4142-B2F7-B603EFA69284.png)

### GBN滑动窗口协议的理解
![](%E4%BC%A0%E8%BE%93%E5%B1%82/EC3F4172-867C-4FE1-B2D3-7EBEF8A88E72.png)
收到ACK（N）的时候表示N之前的分组都被正确收到，超时时重发序列号大于N且还未收到ACK的所有分组。
![](%E4%BC%A0%E8%BE%93%E5%B1%82/D676D907-A9F1-4680-B33D-E4EA32F372DF.png)

![](%E4%BC%A0%E8%BE%93%E5%B1%82/593B00DA-0A79-4B56-B86A-92C3D5CD69E4.png)

### GBN协议的可能问题
因为是累积确认，所以GBN重传分组可能过多，影响传输性能。

### SR滑动窗口协议的理解
![](%E4%BC%A0%E8%BE%93%E5%B1%82/C3CD2569-6820-43EA-82B0-8D449AA152AA.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/A4C64076-B1B9-4C5B-B577-2630807453F6.png)
单独确认每个分组，缓存乱序到达的分组，最小序列分组确认收到后往前滑动。

### SR协议的可能问题
![](%E4%BC%A0%E8%BE%93%E5%B1%82/ED75FBD0-84BB-4DCD-8C7E-018A053B4BCA.png)

# 面向连接的TCP传输
![](%E4%BC%A0%E8%BE%93%E5%B1%82/C520DBC3-1C4C-4B67-A148-647EA8BF287E.png)

## TCP报文端结构
![](%E4%BC%A0%E8%BE%93%E5%B1%82/DDA888C0-A6F8-4FE2-9DF4-0AA6EE1CE402.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/46FC22A8-E594-4AB8-A335-A7AA7049FB79.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/E296AB2F-08DB-4309-A144-54D93F32E692.png)

快速重传为什么是3次？

## TCP流量控制的理解，如果rcvWindow=0会出现什么情况？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/D4EF5533-581E-4EF0-A0D3-DFE4160A6C33.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/4B767696-D395-4248-B151-2320AC29934A.png)
就是控制发送方的速率，不会出现溢出，本质上是速度匹配机制。
原理就是接受方通过在头部字段内放置recwindow告诉发送方自己还能接受最大数据的buffer容量（空闲buffer大小）。

如果大小为0，TCP内部发送方还是会发送一个较小的数据包，因为如果不发会出现死锁，永远不知道过一会的空闲可接受buffer大小。

## TCP连接管理的理解？
![](%E4%BC%A0%E8%BE%93%E5%B1%82/AB783CF2-8CC5-43F9-8F57-D4435D934B57.png)
![](%E4%BC%A0%E8%BE%93%E5%B1%82/DEA38D50-17A9-4B4E-A767-F3B2502A0F7C.png)

# 网络中的拥塞控制
拥塞控制是从网络整体的角度来说的，可靠数据传输更多的是从端到端的个体角度来说的。

拥塞控制的目的是尽量避免网络中的数据发送太快，导致网络中的分组丢失几率过高，或者延迟增大，使网络无法处理。

它和流量控制不同的是，流量控制视角是端对端的，拥塞控制是对整个网络环境。

# TCP中的拥塞控制过程理解




