# Swift各种属性的本质
#Swift/底层解析

# Swift属性的本质总结
* let和var的意义在于能不能修改内存中的内容，且let初始化必须有值。
* 枚举不能定义实例存储属性，但是枚举可以定义类型存储属性（枚举内存是用来放case和关联值的，不会放原始值）
* 计算属性的本质是方法，不会占用实例的内存，不能用let标示。
* 枚举的原始值rawValue本质就是一个计算属性。
* 枚举、结构体、类都可以定义计算属性。
* Lazy属性不能用Let修饰，因为let必须保证初始化完成之前就必须有值。
* Lazy属性不是线程安全的，当多条线程同时第一次访问Lazy属性。
* lazy属性作为对象成员变量时，当前对象不能用let修饰，因为初始化时需要修改当前对象内存空间，而let不允许创建后修改。
* 观察型存储属性在初始化器设置属性不会触发。
* 观察型存储属性在定义的时候设置也不会触发，因为观察型存储属性后赋值本质是在init方法里面初始化（汇编底层）。

# inout本质理解
![](Swift%E5%90%84%E7%A7%8D%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8/D55F4ECA-3F23-4996-8C07-0D2D59037059.png)

### 示例
![](Swift%E5%90%84%E7%A7%8D%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8/DE90FD41-C2A2-4C23-9EC1-6C849AFA215A.png)

 inout输入输入参数的本质是地址传递（引用传递），当传递计算属性的时候为什么也能进行处理呢（计算属性本质是方法，在结构体和类实例对象内存中没有存而是存储在代码段内存空间）？当传递带有属性观察器的存储属性时在内存中的变化过程如下：
	1. 首先还是会在函数调用前，会拿到属性的原始值给一个局部变量并放入一块临时的栈内存空间里。
	2. 再把这个局部变量的地址值传进函数内，修改对应的值。
	3. 函数调用完毕后，再将这个局部变量修改后的值赋到原来带有属性观察器的存储属性里，这时候才会触发属性观察器。

> 为什么传递带有属性观察器的存储属性时不直接传递属性的地址值呢？  
> 从设计层面考虑，目的是触发观察器。因为inout参数这个方法，只关心你传一个地址给我，我修改就行，如果这样的话，属性观察器就不会发生调用，所以用一个局部变量拿到值在函数内修改后再把真正的修改放在函数体外，触发观察器。  

# 类型存储属性的理解
1. 类型存储属性不是存在实例的堆空间里，它是单独存储的，并且只有一份。
2. 枚举可以定义类型存储属性。
3. 类型存储属性默认就是Lazy，第一次访问初始化，并且线程安全（回忆常用的单例写法）。

![](Swift%E5%90%84%E7%A7%8D%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8/871F8FA4-4D1D-4012-BC71-7A2633B90CAD.png)
![](Swift%E5%90%84%E7%A7%8D%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8/7309E01B-819A-40A2-9F40-B43E00E6A96D.png)
前面说过，枚举不能定义存储属性，为什么枚举又可以定义类型存储属性？
因为类型的存储属性并不存储在枚举实际创建的枚举case里，所以没有这个限制，和枚举只存储case标识和关联值也并不矛盾。

### 类型属性的应用
![](Swift%E5%90%84%E7%A7%8D%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8/9B2F1DDA-5958-4F7B-9690-203B793A1C7D.png)