#  进程和线程管理
#操作系统/操作系统

#  进程的概念和特征
操作系统利用进程控制块(Process Control Block, PCB)来描述进程的基本情况和运行状态，进而控制和管理进程。所以从结构上看进程实体是由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。

::创建撤销进程，实质上是创建/撤销进程映像中的PCB。进程映像是静态的，进程则是动态的。PCB是进程存在的唯一标志！::

**什么是进程？**
::进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。::

**特征**
动态性、并发性、异步性、结构性

# 进程的状态与转换
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/FAE01ACE-9793-4E81-91E0-915E476EAD8A.png)
1) 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。
2) 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。
3) 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。

就绪状态 -> 运行状态：获得处理机资源（分派处理机时间片）。
运行状态 -> 就绪状态：处于运行状态的进程在时间片用完后，或者在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正执行的进程转换为就绪状态，让更高优先级的进程执行。
运行状态 -> 阻塞状态：进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。
阻塞状态 -> 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

# 进程控制
在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。

## 进程的创建
允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。一般是如下过程：
1. 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB(PCB是有限的)。若PCB申请失败则创建失败。
2. 进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在PCB 中体现）::注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于”等待状态“，或称为“阻塞状态”，等待的是内存这个资源。::
3. 初始化PCB，主要包括初始化标志信息、初始化CPU状态、控制信息，以及设置进程的优先级等。
4. 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。

## 进程的终止
**引起进程终止的事件主要有：**
1. 正常结束，表示进程的任务已经完成和准备退出运行。
2. 异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。
3. 外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。

**终止进程的过程如下（撤销原语）：**
1. 根据被终止进程的标识符，检索PCB，从中读出该进程的状态。若被终止进程处于执行状态，立即终止该进程的执行，将CPU资源分配给其他进程。若该进程还有子进程，则应将其所有子进程终止。
2. 将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。
3. 将该PCB从所在队列（链表）中删除。

## 进程的阻塞和唤醒
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。

**阻塞原语的执行过程是：**
1. 找到将要被阻塞进程的标识号对应的PCB。
2. 若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。
3. 把该PCB插入到相应事件的等待队列中去。

**唤醒原语的执行过程是：**
1. 在该事件的等待队列中找到相应进程的PCB。
2. 将其从等待队列中移出，并置其状态为就绪状态。
3. 把该PCB插入就绪队列中，等待调度程序调度。

::注意Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。 Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的。::

## 进程切换
**进程切换的过程如下：**
1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

**进程切换与CPU用户/核心态切换是不同的，区别在于：**
如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的CPU现场，无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。

##  进程的构成和如何组织
1. 进程控制块PCB：进程实体的描述，进程存在的唯一标志，主要包括以下部分：
	1. 进程描述信息
	进程标识符：标志各个进程，每个进程都有一个并且是唯一的标识号。
	用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。
	2. 进程控制和管理信息
	进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。
	进程优先级：描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机。
	3. 资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况；所打开文件的 列表和所使用的输入/输出设备信息。
	4. 处理机相关信息，主要指处理机中各寄存器值，当进程被切换时，处理机状态信息 都必须保存在相应的PCB中，以便在该进程重新执行时，能再从断点继续执行。
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/17409BA3-BE0F-43C4-9C6D-1DD0799BDCDE.png)

2. 程序段：能被进程调度程序调度到CPU执行的程序代码段。::序可以被多个进程共享，就是说多个进程可以运行同一个程序。::
3. 数据段：进程对应的程序加工处理的原始数据，或者程序执行时产生的中间或最终结果。

**多个进程如何组织从而方便进程的调度和管理？**
1. 链接方式
将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。
2. 索引方式
是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。

# 进程通信
进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类：
1. **共享存储**
通过特殊的系统调用实现，在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。
::对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。::
2. **消息传递**
进程通过系统提供的发送消息和接收消息两个原语以格式化的消息(Message)为单位进行数据交换，有以下2种方式：
	1. 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。
	2. 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。
1. **管道通信**
一种特殊方式的消息传递机制，“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道。而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。
::为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步、确定对方的存在。::

# 线程和多线程模型
引入进程的目的：
为了使多道程序并发执行，以提高资源利用率和系统吞吐量；
而引入线程的目的：
为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

::一个基本的CPU执行单元，也是程序执行流的最小单元。::

## 线程与进程的区别？
1. 调度方面：在引入线程的操作系统中，线程是独立调度的基本单位。同一进程中线程的切换不会引起进程切换，不同进程中进行线程切换，会引起进程切换。
2. 拥有资源：进程是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），但线程可以访问其隶属进程的系统资源。
3. 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、 I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。同样在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
4. 通信方面：进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。


## 线程的主要属性
1. 每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。
2. 同一进程中的各个线程共享该进程所拥有的资源。
3. 线程是处理机的独立调度单位，单CPU中多个线程是可以并发执行的，多CPU的计算机系统中，各线程可同时占用不同的CPU并行执行。
4. 线程在生命周期内也会经历阻塞态、就绪态和运行态等各种状态变化。

## 线程的实现方式
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/7B2870F8-641E-4D66-8C67-9F07984824C6.png)
**用户级线程(User-LevelThread, ULT)：**
有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。
**内核级线程(Kemel-LevelThread,  KLT)：**
线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。
**组合方式的多线程实现：**
线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。

## 多线程模型：用户级线程和内核级线程的连接方式
1. 多对一模型：将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。
优点：线程管理是在用户空间进行的，因而效率比较高。
缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。
3. 一对一模型：将每个用户级线程映射到一个内核级线程
优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。
缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。
5. 多对多模型：将 n 个用户级线程映射到 m 个内核级线程上，要求 m <= n。
特定：多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。

#  处理机调度和调度算法
处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。简单理解就是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行。具备以下3个层次：
1. 作业调度。又称高级调度。
2. 中级调度。又称内存调度。
3. 进程调度。又称为低级调度。
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/4C4363D0-0977-4DFA-8710-6C68B0195B49.png)

**处理机三级调度的联系**
1. 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。
2. 作业调度次数少，中级调度次数略多，进程调度频率最高。
3. 进程调度频率很高，也是最基本的不可或缺。

##  操作系统典型调度算法 
在操作系统中存在多种调度算法，其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。
### 先来先服务(FCFS)调度算法
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/F246EA27-41E5-4238-A344-57E417075BED.png)
在作业调度中：算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。
在进程调度中：FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。

**特点**
算法简单，但效率低。对长作业比较有利，但对短作业不利（相对SJF和高响应比。有利于CPU繁忙型作业，而不利于I/O繁忙型作业。

### 短作业优先(SJF)调度算法
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/30B47A6C-FC1D-4B8E-B75E-04B360FAB37E.png)
在作业调度中：从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。
在进程调度中：从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

**特点：**
缺点：长作业的周转时间会增加，可能将导致长作业长期不被调度的“饥饿”现象（注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）
优点：SJF调度算法的平均等待时间、平均周转时间最少。

### 优先权调度算法
在作业调度中：优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。
在进程调度中：优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

**根据新的更高优先级进程能否抢占正在执行的进程，可分为：**
1. 非剥夺式优先级调度算法：虽然重要但直到原进程由于其自身的原因而主动让出处理机时才把处理机分配给更为重要的进程。
2. 剥夺式优先级调度算法：高优先级就马上抢占CPU资源。

**根据进程创建后其优先级是否可以改变，可分为：**
1. 静态优先级：优先级不变
2. 动态优先级：根据进程情况的变化动态调整优先级

### 高响应比优先调度算法
主要用于作业调度，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。

**响应比的变化规律可描述为：**
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/1-140629155214919.png)
* 当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。
* 当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。
* 对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。

### 时间片轮转调度算法
主要适用于分时系统，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。

时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。

### 多级反馈队列调度算法（集合了前几种算法的优点）
多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展而来的，动态调整进程优先级和时间片大小。

**多级反馈队列调度算法实现思想如下：**
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/02EF512C-5CA2-4DBA-B390-6D58FA663C46.png)
1. 应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。
2. 赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。
3. 当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。
4. 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。

#  进程同步
虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。

## 实现方法：
[实现临界区互斥的基本方法_C语言中文网](http://c.biancheng.net/cpp/html/2597.html)

#   信号量
一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和signal(S)来访问，也可以记为“P操作”和“V操作”。

> 原语是指完成某种功能且不被分割不被中断执行的操作序列。  
> 不被分割执行特性的功能通常可由硬件来实现。如前述的“Test-and-Set”和“Swap”指令，就是由硬件实现的原子操作。  
> 不被中断执行特性在单处理机时可由软件通过屏蔽中断方法实现。  

## 整型信号量
``` C
wait(S){
    while (S<=0);
    S=S-1;
}
signal(S){
    S=S+1;
}
```
只要信号量S<=0，就会不断地测试，因此，该机制并未遵循“让权等待” 的准则，而是使进程处于“忙等”的状态（自旋）。

## 记录型信号量
``` C
typedef struct{
    int value;
    struct process *L;
} semaphore;
void wait (semaphore S) { //相当于申请资源
    S.value--;
    if(S.value<0) {
        add this process to S.L;
        block(S.L);
    }
}
void signal (semaphore S) {  //相当于释放资源
    S.value++;
    if(S.value<=0){
        remove a process P from S.L;
        wakeup(P);
    }
}
```
一种不存在“忙等”现象的进程同步机制，除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。
**wait操作：**
S.value—，表示进程请求一个该类资源，当S.value<0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，可见该机制遵循了“让权等待”的准则。
**signal操作：**
表示进程释放一个资源，使系统中可供分配的该类资源数增1，故S.value++。若加1后仍是S.value<=0，则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup 原语，将S.L中的第一个等待进程唤醒。

## 利用信号量实现同步（semaphore S = 0）
设S为实现进程P1、P2同步的公共信号量，初值为0。进程P2中的语句y要使用进程P1中语句x的运行结果，所以只有当语句x执行完成之后语句y才可以执行。
``` C
semaphore S = 0;  //初始化信号量
P1 ( ) {
    // …
    x;  //语句x
    V(S);  //告诉进程P2,语句乂已经完成
}
P2()）{
    // …
    P(S) ;  //检查语句x是否运行完成
    y;  // 检查无误，运行y语句
    // …
}
```

## 利用信号量实现进程互斥（semaphore S = 1）
设S为实现进程Pl、P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值应为1（即可用资源数为1)。只需把临界区置于P(S)和V(S)之间，即可实现两进程对临界资源的互斥访问。
``` C
semaphore S = 1;  //初化信号量
P1 ( ) {
    // …
    P(S);  // 准备开始访问临界资源，加锁
    // 进程P1的临界区
    V(S);  // 访问结束，解锁
    // …
}
P2() {
    // …
    P(S); //准备开始访问临界资源，加锁
    // 进程P2的临界区；
    V(S);  // 访问结束，解锁
    // …
}
```

## 利用信号量实现前驱关系
信号量也可以用来描述程序之间或者语句之间的前驱关系。图2-8给出了一个前驱图，其中S1, S2, S3, …, S6是最简单的程序段（只有一条语句）。为使各程序段能正确执行，应设置若干个初始值为“0”的信号量。例如，为保证S1 -> S2、 S1 -> S3的前驱关系，应分别设置信号量a1、a2。同样，为了保证 S2 -> S4、S2 ->S5、S3 -> S6、S4 -> S6、S5 -> S6,应设置信号量bl、b2、c、d、e。 
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/04B56792-6DD6-48E8-AD93-BDF2FE9EFE6B.png)
``` C
semaphore  al=a2=bl=b2=c=d=e=0;  //初始化信号量
S1() {
    // …
    V(al);  V(a2) ;  //S1已经运行完成
}
S2() {
    P(a1);  //检查S1是否运行完成
    // …
    V(bl); V(b2); // S2已经运行完成
}
S3() {
    P(a2);  //检查S1是否已经运行完成
    // …
    V(c);  //S3已经运行完成
}
S4() {
    P(b1);  //检查S2是否已经运行完成
    // …
    V(d);  //S4已经运行完成
}
S5() {
    P(b2);  //检查S2是否已经运行完成
    // …
    V(e);  // S5已经运行完成
}
S6() {
    P(c);  //检查S3是否已经运行完成
    P(d);  //检查S4是否已经运行完成
    P(e);  //检查S5是否已经运行完成
    // …;
}
```

# 经典进程同步问题
 [经典进程同步问题1：生产者-消费者问题](http://c.biancheng.net/cpp/html/2600.html) 
 [经典进程同步问题2：读者-写者问题](http://c.biancheng.net/cpp/html/2601.html) 
 [经典进程同步问题3：哲学家进餐问题](http://c.biancheng.net/cpp/html/2602.html) 
 [经典进程同步问题4：吸烟者问题](http://c.biancheng.net/cpp/html/2603.html) 

# 死锁
多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

**死锁产生的必要条件**
* 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
* 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
* 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
* 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有。

::循环等待条件和死锁的定义不一样，构成循环等待不代表会产生素死锁。::
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/156F1957-7311-4573-B386-CF8DF8B8359E.png)

## 死锁的几种处理策略
![](%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/9EDAFBA4-171B-4525-94B1-BDDD0AFF3129.png)

## 死锁的预防
**1) 破坏互斥条件**
如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。
**2) 破坏不剥夺条件**
当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。

该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。
**3) 破坏请求和保持条件**
釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。

这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。
**4) 破坏循环等待条件**
为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。

这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使甩资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。
