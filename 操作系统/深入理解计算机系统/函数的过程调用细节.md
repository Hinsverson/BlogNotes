# 函数的过程调用细节
#操作系统/CSAPP


![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/24F0061E-2E70-46DE-986A-40D213ADE45D.png)
![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/62F2A9F5-782D-4EF0-9ACE-9309AE39A79E.png)
3个阶段，6个步骤。

![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/4E20D1C8-A80E-4E95-B414-9109947A45E6.png)

![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/EA91BB1C-9034-4422-8FDD-BD2C24CD4449.png)
### P过程阶段：压栈保存必要寄存器、参数、call指令压入返回地址。
首先在Q被调用前，调用者P会把向Q传递的参数进行压栈，最后执行一条Call指令，call指令会根据目的地址（Q的首地址）跳转到Q，同时会把下面一条地址也就是返回地址压栈，然后转移到被调用过程中去执行。
如果P在调用前用了EAX、EDX、ECX、这个三个寄存器，并且想在调用完Q之后还要使用这三个寄存器的值，就要在转到Q前先压栈保存值（这个保存压栈发生在参数压栈之前），等到从Q返回后在恢复它们的值再使用。

### Q过程准备阶段：压栈保存原EBP和必要寄存器（P的现场）、局部变量。
Q执行时，又会在当前栈里重新生成一个栈帧（被调用函数Q的栈帧），一开始在准备阶段会用Push指令压栈保存P的现场（包括调用者P里面EBP寄存器的旧值，还有如果要在Q里用到P中的EBX、ESI、EDI这三个寄存器的话也需要先压栈保存）。

如果执行Q的过程中，有使用到一些非静态局部变量也需要进行压栈分配内存空间。

### Q过程执行后：pop释放局部变量、恢复P的现场和EBP，栈指针ESP回退到P压入的返回地址处。
执行完Q后，如果有用到P中的EBX、ESI、EDI这三个寄存器的话，需要先恢复它们的值，然后再释放局部变量空间，同时Q的栈帧ESP会重新指向栈底EBP，取出原来保存的调用者P的EBP旧值，重新赋给EBP寄存器，然后pop出这块EBP旧值区域，这时候ESP就指向了调用者P栈中压入的返回地址部分。

然后Q执行return的时候就会取出当前ESP指向的调用者P栈压入的返回地址，放到EIP寄存器中，return指令返回后调用者Q根据EIP寄存器去取当前指令继续执行（也就是call指令的下一条指令），同时return执行完后把返回值放到EAX寄存器里，后续指令通过取出EAX寄存器的值来访问返回的调用结果。
![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/81D2B893-E5BA-4921-9566-CD172020A6DF.png)
![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/BEFEC65D-3D26-4383-8A28-1000207B8F91.png)
🌰
一般过程调用
![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/858431D7-C453-405B-B664-524348AA95BA.png)
递归过程调用
![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/17E89E55-F639-4E5A-8F35-716E5732431D.png)
有问题的过程调用
![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/14710263-7C49-493A-9EF6-42206B963421.png)
![](%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82/C5646D48-C08A-434A-A452-BD69C474E27B.png)
因为i>=2后对a[i]进行操作会冲调先压入的a[1]的值，所以返回结果不是3.14。在C中为乐性能不会处理数组越界访问的错误，高级语言一般会直接崩溃。
