# C++学习总结
#C和C++

# 基础常用语法
<a href='02_%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.pdf'>02_常用语法.pdf</a>

[C和C++基础](./C++基础部分.md)

### 理解函数重载的本质？
名字一样，但实际函数地址不同。
### C++默认参数为什么只能从右到左？
::和编译器压栈顺序有关，因为为了支持变参，如果自左向右的入栈那么最前面的参数个数被压在栈底，因为不知道参数个数，所以无法通过栈指针的相对位移求得最左边的参数。从右往左入栈参数个数在栈顶::
### C和C++混编的解决办法？
extern c，并根据__cplusplus配合条件编译的宏。
### 内联函数的优缺点？适用场景？也并不是申明为内联函数编译器就会进行内联优化？
::免去调用栈的开辟，速度快。适用于需要频繁调用的函数。::
### 理解的C中宏的本质？作用对象是什么？宏和typedef的区别？
::预处理时的文本替换。作用对象是除了类型还有普通变量、函数等。::
### 从内存角度理解const修饰的常量的意义？
::记住const修饰的永远是右边的内容，int和const顺序无关也没有影响。::
``` c++
// 理解这5种情况的指针有什么含义？
int age = 10;
const int *ptr = &age; //*ptr 是常量
int const *ptr = &age; //*ptr 是常量
int * const ptr = &age; //ptr 是常量
const int * const ptr = &age; //*ptr ptr都是常量
int const * const ptr = &age; //*ptr ptr都是常量
```
### 理解C++中引用的本质？和指针的区别？
::弱化了的指针，指向后不能再更改指向。::
### 指针也可以有引用吗？
`int *p = &age; int *&ref = p; *ref = 30;`

# 面向对象
<a href='03-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.pdf'>03-面向对象.pdf</a>

[C++面向对象](C++面向对象.md)

### C++中struct和class的区别？
::只是默认访问权限的不同::
### C和C++中struct的区别？
C中不能定义函数，只能用函数指针作为成员变量。
### 理解C++ this指针？
::高级语言函数调用时函数存放在代码空间，通过传入不同实例对象进而访问到不同对象内存模型中的成员变量，进行存取操作。::
### 理解高级语言里指针访问所指向对象的成员变量的本质？比如下面的情况会发生什么？
从指针中取出对象地址+成员变量偏移访存。
``` c++
person.id = 10;
person.age = 20;
person.height = 30;
Person *p = (Person *) &person.age;
p->id = 40; //改的是age
p->age = 50; //改的是height
```
### 访问栈上已被使用空间会崩溃的原因？
C++中栈空间的内存被使用后会被填充为cc，对应汇编指令是程序中断的意思，所以访问会发生崩溃（iOS里也有一个特殊标记）。
### 知道C中向堆空间申请和释放内存的malloc和free函数细节？
::从内存池的申请维护和具体数据结构实现，free如何确认释放范围上说::
### 理解C++中独有的new/delete和C中的malloc和free的区别？
::前者属于高级别面向对象的方式，以类型内存模型申请大小，并会调用C++层面的初始化、析构函数，说白了就是C层面的C++封装。::
### int *p = new int和int *p = new int()的区别
前者即使在全局区内定义也不会进行初始化，后者会被初始化为0。
### C++对象内存分配可以在哪三个地方？是通过什么决定的？
::全局区：全局变量，堆区：通过new，栈区：非new的局部变量::
### C/C++和Swift对struct和class对象的内存管理的异同？
主要是Swift会对struct做优化，放到栈区。
### 理解内存全局区域的特点？
::全局区是一个特殊区域，默认所有对象和数据类型都是0。::
### 构造函数的重要理解？
如果没有为对象自定义构造函数，那么编译器会为成员变量自动进行初始化，如果定义了则不会。
::默认情况下编译器会为每一个类生成无参的构造函数这句话是错误的。::
### C++ namespace的基本使用？嵌套使用？
有一个没有名字的命名空间::，包含所有定义的命名空间。
### 要理解C++中没有基类概念
类似OC中的NSObject。
### B继承于A，在内存布局里AB的成员变量是怎样的情况？
先放A，再放B。
### C++中的访问权限有哪几种？理解protected？
::private、protected：子类内部可以访问、public::
### 发生继承后子类访问父类成员的权限由什么决定？
成员本身权限和继承权限。
### C++初始化列表的理解
C++初始化列表是一种快捷的初始化语法糖。::初始化列表初始化，赋值的顺序只和变量申明的顺序有关，初始化列表可以和默认参数一起使用。::
### 结合this指针理解C++中为什么不能在无参构造函数调用有参构造函数？如果确实需要的话要通过什么形式？
::如果在无参初始化方法里调用有参数的，有参数的初始化方法里的this不是外面生成的那个对象，而是一个临时的对象，会导致初始化失败。如果确实需要可通过初始化列表完成无参调有参。::
### C++在子类中父类构造函数调用的默认规则是什么？如果子类显式调用父亲类无参的构造函数是什么情况？如果父亲类没有无参的构造函数又要怎么办？
::默认是调无参，如果显示调用就不会调用无参了，如果没有无参则必须显示调用有参。::
### 理解C++中类对象构造和析构的顺序？
::构造从父类到子类，析构从子类到父类（和OC一致）。::
### C++中父类指针指向子类对象时是否具备多态性？如果没有要实现多态如何实现？
默认没有多态，只会根据指针的类型去找对应的方法进行调用，用virtual函数实现多态。
### 添加virtual修饰的函数后对象的内存布局有什么变化？
前面多了一个指向虚表的指针。
### ⚠️对C++虚函数调用过程，以及实现多态的理解？
1. vurtual修饰符的作用就是延迟绑定，运行时决议，vurtual意味着对象的内存布局里前4个bety存储着一个指向需表地址的指针，虚表里记录调用函数的地址完成调用。
2. 父类中有虚函数，则子类内存布局的里也有指向父类虚函数表的指针，多个继承就有多个，顺序按照继承的顺序放置。如果子类也有虚函数那么在放置完父类虚表指针后也会放置指向子类自己虚表的指针在内存布局中。
3. 如果子类去重写了父类的某个虚函数，会替换掉父类虚表中对应的函数地址，此时用父类指针指向子类对象就会发生多态。
### 父类析构函数为什么一般声明为virtual（从多态性的角度）？
::声明为virtual的虚析构函数才能在多态的场景下根据类型去调用对应的析构函数，完成正确的内存释放。::
### 理解纯虚函数和抽象类？
类似接口，如果父类是抽象类子类没有完全重写虚函数子类还是一个抽象类。
### ⚠️理解C++对象多继承的内存布局方式？多继承下多个父类都存在虚函数子类的内存布局？
::内存布局中先继承的成员变量在前面，多个父类都有虚函数，那么内存布局里会产生多张虚表，重写后放置的是重写后的方法地址。::
### ⚠️多继承下多个父类都存在虚函数子类的内存布局？如果存在普通同名函数又是什么情况？同名成员变量呢？
::通过指明的方式完成同名父类函数和成员变量的访问，并且会把同名的所有成员变量继承下来，内存布局顺序由继承顺序决定。::
### ⚠️棱形继承情况下的内存布局？所带来的问题？如何解决，解决的原理是什么（重点是理解内存布局的变化）？
![](C++%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/C762F8DF-C056-4733-8D82-712848731E47.png)
![](C++%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/3191C35B-CEEB-458E-A482-807F12340A9A.png) ![](C++%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/38662512-5E35-4C57-9553-D71D93238923.png)
1. 本质通过虚表来解决，如果是以虚继承的方式继承某个类，那么内存布局里会在前面插入4个字节存储一个指针指向虚表的包装结构地址，该结构里会存放2个东西，1个是真正的虚表指针和本类起始地址的偏移量（相当于标记虚表指针在本内内存布局中的位置），1个是继承过来的虚基类第一个成员变量与本类起始地址的偏移量（相当于标记虚继承过来的成员变量在本类内存布局中的位置）
2. 子类菱形继承时，继承了几个虚继承的父类就会产生几张虚表，内存布局时会把虚继承过来的基类成员变量放在本类成员变量后面，通过虚表内的偏移量去找。
### 多继承的使用场景？
类似遵循多个协议。。。。。。
### C++ static静态成员变量必须在类外部初始化，静态成员函数不能是虚函数，当声明和实现分离时，实现不能带static。
### 实现一个C++的单例？
![](C++%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/07D1935B-813A-4F36-BAE6-BCAC9BDE4F97.png)
### 知道C++中Delete会不会清空指针
### 理解C++中const修饰的成员变量和函数？
1. const成员函数内不能修改非static成员变量，只能调用const函数和static函数。
2. 非const成员函数可以调用const函数。
3. const成员函数和非const函数构成重载。
4. 非const对象（指针）优先调用非const成函数，const对象（指针）优先只能调用const成函数、static函数。
### C++拷贝构造函数写法？理解为什么需要使用&？默认拷贝构造？什么情况下才需要重新实现拷贝构造？
1. ::Car(const Car &car)，如果不用引用传递的话会无限的进行拷贝构造。::
2. C++如果不写会默认生成一个拷贝构造函数将所有成员变量进行拷贝赋值
3. 知道拷贝构造需要写的场景是当有指针类型的成员变量时，希望进行深拷贝时。C++编译器默认提供的拷贝构造函数是浅拷贝。
理解下面的示例为发生什么？如何解决？（初始化的时候拷贝到堆空间）
``` c++
// 会发堆空间对象内的指针指向了栈空间，容易发生野指针访问
// Car的初始化函数为Car(char *name)，内部有一个name指针
Car *car
void test() {
	char name[] = {‘a’, ‘b’}; 
	car = new Car(name);
}
```
### C++里使用对象类型作为参数和返回值时为什么一般使用引用或者指针？
::因为防止拷贝构造产生不必要的中间对象。::
### explicit是用来干什么的？
禁用隐式构造
### 知道什么情况下才会为类生成无参的构造函数，以便初始化？
::只有在一些特定情况下会生成（这种特定情况可以理解为创建完后有事干，也就是初始化一些东西，比如：::
1. 有定义虚函数
2. 存在虚继承
3. 包含了对象类型成员，而且这个成员有构造函数
4. 父类有构造函数
### C++友元的理解？一般什么场景下使用？
一种编译器特性，用来访问权限的控制，类A声明为类C的右元类，那么A的成员函数里就能直接访问C对象的成员。

# 其他语法
<a href='04-%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95.pdf'>04-其他语法.pdf</a>

[C++其他语法](C++其他语法)

### 了解运算符重载的基本写法？
![](C++%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/91DACEAF-B5FD-4DE3-BA4C-E63770F9166B.png)
### 理解模版的本质是什么？如果模版没有被使用会不会实例化出来？
编译器特性，编译器会根据传入的类型生成不同的函数。
模版没有被使用，不会实例化，意思是不会生成额外的代码。
### 基于模版的申明和实现如果分离到.h和.cpp会导致什么错误？为什么？
::因为申明和实现分离，编译都是靠文件的单独编译，最后进行链接。单独编译实现的时候，没有任何模版调用就不会生成任何模版实现，所以最后编译的目标文件内并不会有任何模版实现代码，所以会导致最后链接错误。::
### 数组动态扩容的原理？
::先申请一块一定大小的连续堆空间，通过指针指向第一个元素。::
::如果不断加入数据存不下了就申请另一个更大的堆空间，将原来的数据搬过去，再改变指针指向的位置，最后释放旧空间。::
### ⚠️C++4种强制类型转换的理解？
1. const_cast：用于将const变量转为非const
2. static_cast：一般用于非const转const，缺乏对多态类型的安全检测。
3. dynamic_cast：一般用于动态类型转换，所以会有安全检测（非法的对于指针返回NULL）。
4. reinterpret_cast：这种转换就是存储的二进制数据直接赋值（将int转指针），比较底层，没有安全检查。
::C语言的强制类型转换是直接赋值，没有安全检测::
### auto、decltype的理解
auto：编译器自动类型推断。
decltype：获取变量类型。
### ⚠️C中的NULL和C++有什么区别？nullptr主要用来解决什么问题？nullptr是什么类型的？
NULL 在C中是 ((void *) 0)，NULL在C++中是0。
因为C++中不能将void *类型的指针隐式转换成其他指针类型，比如	`int *a = (void*)p`，所以不能将NULL定义为(void*)0。
为了解决二意性的问题引入了nullptr，nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。
![](C++%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/95B3A502-A969-48B3-B7AF-AA78B5A91F0F.png)
### ⚠️理解C++中lambada？默认是什么捕获？捕获的基本原理和过程？值捕获和引用捕获的区别？对比理解和Swift的异同？知道值捕获到的变量不能修改，如果要修改需要加mutable（本质是2个不同对象）。
1. 总的来说就是Swift做了更多的事情（逃逸时会拷贝到堆上），而C++不会所以要注意被捕获对象的生命周期问题。
2. C++默认都是值捕获。
3. 默认值捕获到的变量是不可变的，类似Swift捕获的let，但是可以使用Mutable修饰的lambada可以修改捕获到的值，::外部a依然不会变，但是block里面的a变化了::

对比理解：  
OC：默认基本类型都是值捕获，通过__Block包成对象达到指针捕获的效果。
Swift：默认基本类型、结构体对象隐式的捕获都是指针的捕获，显示的进行赋值捕获时根据是值类型还是引用类型决定是值捕获还是指针捕获。
C++：默认基本类型都是值捕获，通过&来进行指针捕获，

![](C++%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/112A5F84-BD87-4C23-B224-6FC68C2CF505.png)
### C++ throw异常后catch的寻找规则是什么？
向上找，catch(…)的意思是拦截所有异常。
### 理解C++中的智能指针：
1. 类似高级语言里的2种强弱指针：
	1. shared_ptr：类似强引用，对象被shared_ptr指向一次引用计数+1，shared_ptr销毁时引用计数-1，为0时对象自动销毁。
	2. weak_ptr：类似弱引用，引用计数不会+1
2. 特殊的指针unique_ptr：强引用，但是能保证同一时间只有1个指针指向对象，unique_ptr销毁时，指向对象也就自动释放了。