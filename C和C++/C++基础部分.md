# C++基础部分
#C和C++

![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/C2EF0D16-8B41-4699-B9E0-64B0BF46443A.png)
Java要先有类，再有函数（Main入口）。
程序的执行都是转换为汇编代码，汇编代码和机器码一一对应，每行代码都是存在内存中，翻译为机器码（01）由CPU读取并执行。

# C++支持函数重载
本质：是编译器内部通过不同的函数名表示一个函数，并且存储在不同的内存地址中），C不支持。
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/5CCB2957-E965-43A9-BF29-722609947FF7.png)

# C++默认参数
1. 从右到左带默认参数
2. 默认参数可以是字面量、函数等
3. C语言函数可以作为参数，但是不支持默认参数  

![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/52818177-5ECA-48B9-96A5-424C0CDF866F.png)
```
//func是一个函数指针，可以通过函数指针调用函数。
void(*func)()
```

# C++ 和C的混编
通过extern “C”在C++中桥接C的方法
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/30F2040C-F68B-4C97-96AE-E2B42526D2F1.png)

通过宏定义和extern让C代码在C和C++中都能兼容。
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/5726B4A9-A141-4134-A17E-B02D0F7C35CD.png)

拷贝文件内容来参与编译
```
#include <stdio.h>
```
条件编译：如果定义了
```
#ifdef __cplusplus
 …
#endif
```
条件编译：如果没有定义math_h这个宏就定义一个，其次因为定义了math_h这个宏所以条件成立参与编译。
```
 #ifndef math_h
 #define math_h
 …
 #endif
```

![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/A574C588-ABBC-4A66-9C7D-AE0E3D90F6E8.png)

# 内联函数
一种编译器特性，申明后编译器会（考虑）将函数体内代码编译时直接展开插入到到正在编译的位置。

优：免去函数每次调用时开辟和回收栈空间的开销

缺：代码体积会增大

使用场景：频繁调用、函数内体积不是很大

> 即使申明为内联函数，如果编译器发现函数内体积很大（行数）也不会进行内联优化，函数内存在其他函数调用也不会进行内联，该关键字申明只是建议。  
> 一般在release的时候即使不声明。编译器也会进行可能的内联优化。  

# 宏
本质只是文本的替换
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/9D6B2C76-D5F7-474E-AF21-AC49917C3452.png)

# 表达式
C++表达式可以参与赋值操作（此时的a为4）
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/ACCEF126-6843-40FC-B218-8B763AE98331.png)

# 常量Const
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/71072049-3AE4-4EF2-9F6C-88A1C4EFA4DF.png)
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/DE25E4DD-942F-4DC8-BB9F-2411AE5E42A4.png)
结构体对象本身访问成员变量用.

指针访问成员变量用->

*p为取出指针所指向的对象，所以可以用.

## 例1
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/7861A433-B7FA-47AB-B095-14CDD5D162AB.png)
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/A3E1B5C6-C33E-4AF2-9145-883ABBF6D652.png)
结论：
Const只修饰右边的内容，类型名和Const顺序没有本质区别
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/7C911A49-8117-4046-8063-FCA609D944E3.png)

## 例2
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/CEB134D6-60B3-4ABD-AB4E-9B33BBF02CBE.png)
结论：
Const修饰*pStud1表示禁止使用指针去修改指向的内容
Const修饰pStu2表示禁止再指向其他内容

# 引用
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/1CA7980A-B4E9-4020-BD0C-FD7CFF7627E9.png)
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/B437D8EF-CA5C-41FD-90EC-92896049E4A9.png)
引用的本质和指针的区别：区别在于引用一旦指向某个变量，就不可以更改指向，指针既可以修改指向也能修改内容。

> 从汇编看引用的本质就是指针，只是弱化了指针，指定后不能再瞎指，更安全。  
> 指针的大小和架构环境有关，一般x64是8个字节，x86是4个字节。  

## 指针也可以有引用
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/5D7F1AF6-BFFC-4F56-8B50-65B37FA7CEC8.png)

## 常引用
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/FAE0C0AA-32D1-4E25-9247-A80DF30189A9.png)

## 举例
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/BBE3A098-7DAD-43FC-819D-F9A610C56693.png)
不能通过引用去修改值，只能访问。
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/A2FB9BF7-E72A-43E2-9190-CDBE3E35DC25.png)
![](C++%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/B94C3628-5A3E-45C2-A1E6-0DC0F1FEDCFC.png)
该函数能访问地址内容，不能修改。
