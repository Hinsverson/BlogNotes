# C++其他语法
#C和C++

# 运算符重载
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/91DACEAF-B5FD-4DE3-BA4C-E63770F9166B.png)
Const引用能接收const和非const修饰的参数，接入面更广。

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/919D1F01-5EA6-4040-86FF-DFE444D82D79.png)
传入参数是引用类型
返回一个Point对象的引用（因为返回对象的话会产生中间类型）
*this表示取出this指针指向的对象
对象用.访问，指针用->访问

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/D31268D6-610D-4DA2-83C7-0095EBB113C6.png)
前一个const是限制返回值不能被赋值，后一个const是希望又能继续 被返回的const对象调用。
⚠️const函数只能被const对象调用

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/46601E04-A613-4695-94D7-08158AE4BF9B.png)
重写<<运算符，cout是一个ostream对象。

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/2F685804-9FD0-4A09-AF77-698EB0D018D5.png)
重写>>

## 仿函数（本质是函数重载）
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/E5063128-3416-4822-A56F-A268347CD27D.png)

## 注意点
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/39CD4933-E055-4616-83D6-78A8644F68A0.png)

# 模版（范型）
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/C94F6F37-1A9E-4BA4-836F-2339C30C928E.png)
类似模版这种是编译器特性，编译器会根据传入的类型生成不同的函数。
没有实例化的意思是不会生成额外的代码。

# 编译链接
头文件不会参与编译，只是在编译时进行了申明拷贝到.c文件。
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/F1452BBD-698C-448D-A39C-F5E1F79433B7.png)
1.首先文件都是单独编译，遇到函数调用则生成一个call函数地址的汇编（此时的函数如果是另一个类的函数，则地址是一个临时地址）
2.通过链接去修正需要调用的真实函数地址。

## ⚠️模板的声明和实现如果分离到.h和.cpp中，会导致链接错误
因为申明和实现分离，编译都是靠文件的单独编译，最后进行链接。单独编译实现的时候，没有任何模版调用就不会生成任何模版实现，所以最后编译的目标文件内并不会有任何模版实现代码，所以会导致最后链接错误。

# 类模版
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/DA524CF4-C2CE-4B44-8453-5BB75CB72639.png)
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/B88B65A0-2119-45F6-ADC9-5CE3EBECF578.png)
为了实现打印重载<<操作符，友元申明也支持模版函数。

## 数组动态扩容的原理
先申请一块一定大小的连续堆空间，通过指针指向第一个元素。
如果不断加入数据存不下了就申请另一个更大的堆空间，将原来的数据搬过去，再改变指针指向的位置。
最后释放旧空间。
⚠️用C++实现一个Swift的数组。

# 类型转
C语言的强制类型转换是直接赋值，没有安全检测

## const_cast
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/618E84F1-A38A-4788-B56B-98ECFF800724.png)
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/11689F06-FB22-420E-B3D1-4AB06889B1C5.png)
C语言风格和C++风格强制类型转换本质上都是赋值操作，没本质区别。

## dynamic_cast
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/B5BB9B0A-F52A-4424-9FF4-206FDD29EFB8.png)
C++里NULL相当于空指针（地址为X000000000），和C语言的(Student *)强制转换不同的是dynamic_cast会在发生不安全的类型转换时将指针置为空指针。

## static_cast
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/74D1151C-2107-4B07-9341-77F9F656254F.png)
一般不同这个，直接用C语言风格转换就可以了。

## reinterpret_cast
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/7F5E0B42-CEC3-4872-B763-7BCD71775DFA.png)
就是存储的二进制数据直接赋值，一般不常用。


# C++新特性
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/37C679E9-EE32-48D9-8115-0F76314E7C16.png)
NULL的本质是宏0，从C++2011开始，NULL就是表示一个整数0，建议使用nullptr代表空指针。

NULL C中是 ((void *) 0)，NULL在C++中是0，因为C++中不能将void *类型的指针隐式转换成其他指针类型，比如	`int *a = (void*)p`。所以不能将NULL定义为(void*)0。为了解决二意性的问题引入了nullptr，nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/95B3A502-A969-48B3-B7AF-AA78B5A91F0F.png)


# Lambda（类似闭包）
[C++ lambda表达式教程 | 赖思理的博客](https://lesleylai.info/zh/c++-lambda/)

overload了 operator() 的一个匿名类的一个对象，如果你是在配合模版使用 Lambda 表达式，你就很可能需要显式地告诉编译器我想把这个看做成一个函数。
``` C++
#include <iostream>

class Foo {
public:
    explicit Foo(void(*func)()) {
        std::cout << "using function pointer constructor" << std::endl;
    }

    template <class T> explicit Foo(T t) {
        std::cout << "using template constructor" << std::endl;
    }
};

int main() { Foo([](){}); return 0; }
// 输出 using template constructor
```

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/EFF34C48-D8BF-446A-9ACC-E21A49B88FDB.png)

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/0578A932-9EF5-4ED0-B9E7-D125E521B59C.png)

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/58A66C37-BDEA-4BBA-BC32-05E40D36B01C.png)
通过函数指针去存储，也可以使用auto推断。
[]是标志不能省略，类似block的^。

## 捕获
[C++中lambda表达式详解与原理分析_LPWSTR的博客-CSDN博客_c++ lambda 原理](https://blog.csdn.net/LPWSTR/article/details/79633944)

创建lambda表达式时会创建lambda匿名类，Swift也是一样都可以把闭包看成一个匿名对象。
lambda匿名类会将捕获参数中的变量添加到其成员变量中，并设置一个带有该参数引用类型的构造函数。
lambda表达式中的代码是在一个单独的函数中执行的，这个函数在调用时创建了自己的栈帧，捕获就是创建栈帧时的压栈操作，

值捕获时，C++编译器在构建lambda表达式的匿名类时将局部变量的引用传入，并在构造函数中完成对相应成员变量的初始化赋值。在调用其operator()函数时，如果用到了捕获列表中的局部变量，则从给匿名类对象的成员变量中取出。

引用捕获也是在构建lambda表达式的匿名类时将局部变量的引用传入，只是是直接存指针到了成员对象中，指向的还是同一个对象。

**和Swift的相似**
类似的闭包表达式，其实都可以看成一个匿名内部类，只是在运行时内存分布的位置不同（C++ new分配的才在堆上，swift值类型在栈，引用在堆上），捕获的变量可以看成成员变量，表达式的执行可以看成该匿名类的函数调用，执行时压栈操作进行捕获变量的传递。

**和Swift的区别：总的来说就是Swift做了更多的事情**。
Swift里可以隐式的不写捕获列表从而进行默认的强引用捕获。
Swift里捕获的临时变量当外部生命周期结束时（函数出栈）内存布局会从栈拷贝到堆空间（逃逸闭包），以防止外部生命周期结束时（函数出栈），内部捕获到的变量已被销毁（野指针）的情况，使用完后会自动释放堆空间内存。

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/112A5F84-BD87-4C23-B224-6FC68C2CF505.png)
默认都是值捕获。

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/46252A47-B887-4112-BE32-49C0F27BC926.png)
默认值捕获到的变量是不可变的，类似Swift捕获的let，但是可以使用Mutable修改捕获到的值（外部a依然不会变，但是block里面的a变化了）
``` C++
int a = 123;
auto f = [a]()mutable { cout << ++a << endl; }; // 不会报错
cout << a << endl; // 输出：123
f(); // 输出：124
cout << a << endl; // 输出：123
```

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/E24FA9B8-BD3F-4453-926A-F9FBC22BEE9D.png)
全局变量不需要捕获，因为存储在全局区，临时变量需要捕获才能访问，因为它在栈空间，后面会被释放，值捕获相当于拷贝一份，地址传递的捕获相当于放到栈上延长生命周期，避免被释放后无法访问（和swiftOC一致）。

# 异常处理
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/0FCE96A2-4F70-4D76-A22C-BB1CA2BEF1D5.png)
Try里一旦出现异常，马上跳到catch里处理

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/911B1F73-F5F1-4A3C-ABFC-D2FE6E671183.png)

抛出异常
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/17586B5F-8C55-4986-9962-1727BD07D641.png)

自定义异常
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/4AE47A59-2A0F-455B-A155-518514B739DC.png)

拦截所有异常
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/D43EF631-554A-4E1C-9C4D-71538BD54FE1.png)

标准库异常
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/08C368ED-847C-4137-8947-68409334CC9A.png)

# 智能指针的本质
# auto_ptr（不推荐使用）

![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/B7DF4F63-0C36-4F76-B7C1-052510132566.png)
通过模版创建一个auto_ptr类型的智能指针变量，auto_ptr就是类型所以不用写*，后面是调用构造函数进行构造。

⚠️本质相当于通过范型（模版）把指针包了一层，然后自动管理内存。当指针变量被释放的同时释放指针变量存储指向的堆空间地址内存）
⚠️智能指针要指向堆空间对象，如果指向栈空间会导致多次释放，可能出现问题，

⚠️智能指针简单实现类似如下：
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/D6CA3E52-06B3-4E50-901A-2A11025BCFD5.png)
⚠️通过运算符重载实现外部调用。

# shared_ptr（强引用指针）
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/72427E2F-C478-46FC-9E07-9CB2D07489A3.png)

原理：引用计数
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/1CC5E3C1-8E53-4B8D-B9ED-1BD214E8653A.png)

问题：循环引用
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/AF9FC512-DF32-4B55-83FF-E354CF6171AC.png)

解决：弱指针（weak_ptr）

## weak_ptr（弱引用指针）
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/22EF588E-FF70-47EF-9529-40E472E98FD6.png)
原理：引用计数不会+1

## unique_ptr（同一时机只有一个强引用指向）
![](C++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/C27A91AB-98CA-4D72-9E80-DD9FBC2C85D8.png)



