# C++面向对象
#C和C++

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4D415466-4807-4A7F-B358-07D24AD75490.png)

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/815BBC1B-9443-4683-936E-8D649621AE5F.png)
C语言只有Struct，只能定义成员变量，不能定义方法，但是可以用指向函数的指针去模拟面向对象思想中的方法。

C++Struct和Calss除了默认访问权限，其他没有区别，struct的存在是为了兼容C。


![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/541B1A59-839D-480B-B61D-0E4FAB9D0606.png)


# This原理
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/953E08B6-672C-4529-BF81-2D1BFAC8CC14.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/41573449-D2BC-4289-8D63-70530826A76B.png)
C++函数调用时会把对象地址隐式的传到函数里，这就是为什么函数地址在栈空间中，各对象公用，但是函数内依然可以访问不同对象成员变量值的原因（Swift也是这种机制，this存放在特定的寄存器，然后函数调用的时候压栈）。

# 指针访问所指向对象的成员变量的本质
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/AD146023-A1B0-4CA6-A2A5-632B97A6770B.png)

指针访问例子：
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/963CDEC3-6300-4A70-A39B-F46680E0B464.png)
```
//mov eax, dword ptr [p]
//mov dword ptr [eax + 0], 40
p->m_id = 40;
```
指针p里存储的是person对象的成员变量m_age的地址， m_age的地址其实是对象地址+4个字节的偏移，所以exa存储的也是对象地址+4个字节的偏移，所以上面通过p去修改m_id其实修改的是m_age地址空间所存储的内容。

> `Person *p = (Person *) &person.m_age;`  
> (Person *)为强转，把int * 转换为 Person *。  

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5C866C4D-6652-4CAE-8670-FFA680C3BC7C.png)
所以访问m_height的时候会出现越界的情况，这个时候访问的内容其实是cc（int3）中断，程序会停止。

> 栈空间的内存如果使用过后会被填充cc，cc对应的汇编指令int3就是中断的意思，所以程序会停止。  

# 内存空间的布局
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/D6D30B2C-FC8E-47A6-A1D8-8F370EAF82B6.png)

# 堆空间内存申请和释放 
## C语言方式malloc/free
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8911BB74-0164-401E-B282-CD1C2931AE83.png)
malloc向堆空间申请一块连续的内存，返回内存块的首地址。
free释放一块内存空间，参数为那块内存空间的首地址。

> malloc的返回值是（void *），是一个地址，所以用指针来保存。所申请内存块的具体当作什么来使用根据实际情况而定，因为这4个字节的内存块我们希望存放int类型的数据，所以强制类型转换为（int *），用一个（int *）类型的指针来保存它，可以理解为p指向所申请4个字节大小的内存块的全部。  
>   
> 强制转换（char *）可以理解为p指向所申请4个字节大小的内存块的第一个字节（char类型占一个字节）。`*p = 10` 是在对第一个字节进行赋值，*（p+1）是对第二个字节进行赋值，依次类推（p[0]、p[1]这种是C语言语法，完全等价）。  

### 函数内的malloc
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/24A7705E-AEAF-4102-AB59-F4FB93535895.png)

x86，32位环境下，指针变量占4个字节，指针变量内存在栈空间，存着指向堆空间的地址值。

## C++独有方式new/delete
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01BC3909-B971-4CE3-97FE-71CF59033425.png)
通过具体类型申请，不用类型转换，是一种面向对象的方式。
> ⚠️通过new方式创建对象会进行初始化函数的调用，malloc创建对象不会调用初始化函数，free也不会调用析构函数。[细说new与malloc的10点区别 - melonstreet - 博客园](https://www.cnblogs.com/qg-whz/p/5140930.html#_label1_4)  

## C++独有方式new[]/delete[]
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/B99311E7-A433-41D8-817D-CE19ADC9893C.png)
通过数组的方式申请，释放时注意也要数组形式释放
> ⚠️注意此时p指针指向4个字节中的第一个字节。  

# 堆空间内存初始化
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4B222F90-5481-456A-A61C-3A238527CE57.png)

## 内存空间初始化memset
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6775D193-91F6-4846-8280-E85D1BE7B510.png)
第一个参数是一个地址，第二个是初始化值，第三个是初始化的大小
`memset(p, 0, 40)`表示从p所指向地址开始的40个字节内存空间都用0填充。

## 内存空间初始化new
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/334E0722-3839-46EA-9D07-535650FBBF64.png)
通过`new int()`可以进行初始化赋值，没有传入具体数值则赋值为0，只是`new int`不会进行初始化。

# C++对象的内存分配位置
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/48284D69-CC87-4684-9FB0-280335FA5412.png)
> ⚠️Swift和oc对象只能分配在堆空间，C++通过 Person person;这种形式在栈空间里就分配在栈空间，new在堆空间。  

# C++构造/析构函数

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/637892A4-C325-4224-BA35-CB2228746CD2.png)

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/F205BDA3-FB88-4980-BF25-65A961F23E4A.png)
全局区比较特殊，默认所有对象和数据类型都是0，如果没有定义构造函数，则`new person()`会进行成员变量初始化，如果有构造函数，则编译器不会初始化。

> ⚠️通过new方式创建对象会进行初始化函数的调用，malloc创建对象不会调用初始化函数，也不会调用析构函数。  
>   
# C++指针/对象内存分布举例
指针和对象的内存分布由申请方式决定。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/05B48599-2856-4938-858F-6C4163E1369C.png)
指针变量在栈空间，car对象在堆空间

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4E082C43-97C5-4659-802A-5CAAEDEA7E8E.png)
Car对象在栈空间（C++和Swift不一样，很多其他语言对象都是在堆空间，在栈空间保存一个指针引用指过去，这是有区别的。）

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/E6D4280D-4BA4-496E-AF0C-76D4479C84D6.png)
New创建的对象在堆空间，栈空间保存指向它的指针。


![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/D7E6B6DC-6961-460F-BD3A-28FDF515AEE4.png)


![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/624ADE20-2312-4643-97A4-DDB13919E350.png)


# C++申明和实现分离
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8E61F509-75EF-4011-867A-36CF9A3F42F4.png)
用类名：：表示某个函数属于这个类

# 命名空间
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3BC9759D-205C-4253-B466-AD45DA66B19E.png)

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4DEEE452-A8EE-49B6-900C-23B8FD18503C.png)
有个全局的没有名字的命名空间(：：)，所有命名空间都嵌套在里面。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/CE7C0180-B1F4-4953-9828-B5C16A4B353F.png)

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1DC70251-9457-49D2-9792-48F6A177A497.png)

# 继承
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1615D0A0-19CC-4422-9B69-477D71DB2729.png)
C++继承没有基类概念（oc的NSobject）

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/237F1781-145C-4220-978F-318EC6807DEF.png)
继承发生后，父类成员变量在内存空间的前面，子类按顺序在后面。

# 访问权限
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1AEF8865-5BF3-4AB1-AF31-F6EF0B19F0DE.png)
继承后的成员权限取由成员本身权限和继承权限共同决定。



# C++初始化列表
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9A286D4A-227C-48D5-819A-199EC0A6EFF9.png)
通过初始化列表初始化，赋值的顺序只和变量申明的顺序有关。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/127649B3-FFAD-45C6-922B-E170ADB8F5E8.png)
先初始化age，由于此时m_height还没初始化，所以是一个未知的值。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/A4DCCF2F-36B4-4A73-BF2C-9B2AC41B6865.png)
初始化列表可以和默认参数一起使用（和Swift类似，表面看相当于重载了几个不同参数的函数）


# 构造函数相互调用初始化规则
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/D72DD28A-A043-4F6C-8105-55FEC2427E8E.png)
如果在无参初始化方法里调用有参数的，有参数的初始化方法里的this不是外面生成的那个对象，而是一个临时的对象，会导致初始化失败。（Swift里面可以这么干，本质是语法糖），可通过初始化列表完成无参调有参。

**⚠️无参调用有参，需要配合初始化列表（初始化列表是一种语法糖，本质就是将冒号后面的参数赋值给成员变量）**

> C++函数调用（包括初始化方法）时，汇编的本质是把对象本身通过this指针传递到函数里面（和Swift的self一个概念，表示当前对象）。  
>   
> 初始化方法会生成一个对象再用this指针指向这个对象，传递到初始化方法里。  

# 父类构造函数调用规则
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8DC8772D-510A-4958-B49F-A14D10EE8B52.png)
子类默认调用父类无参的构造函数

示例
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/A95889BC-E4C2-4CB2-83E1-7F27E5C536CA%202.png)

# 构造和析构顺序
构造从父类到子类，析构从子类到父类
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/E08858AE-9AB9-4C73-8DD1-32C917CF8A8B.png)



# C++多态
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6DD7A3C5-6E53-4800-851D-7121D18CEBFD.png)
C++编译器默认没有多态，只会根据指针的类型去找对应的方法进行调用（上面虽然创建了一个Dog对象，但是用父类Animal指针指向它时，只会调用Animal里面的speak和run方法）

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/438BE971-45FE-4B1F-8E74-2B1A364C6E49.png)
即使Cat类和Dog共同继承Animal，但是2者并无关系，最后也是调用指针类型（Cat）的方法。（有点离谱）不会调用实际指向对象的方法。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/D28DD75F-C6B5-4699-8D04-6935E9032EC6.png)
通过虚函数实现多态


# 虚函数实现多态的原理
**vurtual和C++虚函数、多态的综合理解：**
1. vurtual修饰符的作用就是延迟绑定，运行时决议，vurtual意味着对象的内存布局里前4个bety存储着一个指向需表地址的指针，虚表里记录调用函数的地址完成调用。
2. 父类中有虚函数，则子类内存布局的里也有指向父类虚函数表的指针，多个继承就有多个，顺序按照继承的顺序放置。如果子类也有虚函数那么在放置完父类虚表指针后也会放置指向子类自己虚表的指针在内存布局中。
3. 如果子类去重写了父类的某个虚函数，会替换掉父类虚表中对应的函数地址，此时用父类指针指向子类对象就会发生多态。

一句话，申明为虚函数使得函数的派发同过虚函数表派发，也使得该类的子类具备多态行为。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/C7F3AF7E-0CF8-4B5D-9408-6AA59E2F11D6.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/A24812C6-7D64-4F6D-A81B-810ECD516DC4.png)
C++虚函数内存布局和多态原理和Swift vtable类似，对象的方法地址被维护在一张表内（一块连续的内存区域），使用virtual关键字后，编译时对象的内存布局中从首地址的前4个字节存储的不再是第一个成员变量，而是虚函数表的地址，通过这个地址找到对象的方法列表，按固定偏移字节大小去读取函数表中存储的方法地址，找到方法地址去调用代码区中的代码。

相当于在运行时去动态的找类型，再找对应的方法，有点动态性的意思。

## 虚函数表和函数重写
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/672C962C-24BC-4595-A802-976476893903.png)
如果子类重写了某一个方法，那该类的虚函数表内直接放置的是重写后的方法地址，如果没有重写，放置的是父类的该方法地址，调用父类所实现的方法。

**⚠️C++和OC对象runtime那一套还是有区别，OC运行时机制是按继承关系依次往上找，C++是编译后直接把方法地址保存在维护的一张表内，不存在查表的操作。**（函数表派发都这样）

> Virtual修饰的函数为虚函数，多重关系继承下，父类指针指向子类调用函数，是否发生多态行为的关键是看父类所调用的方法在父类里是否用virtual修饰，而不是看该方法在子类中是否申明为虚函数。  

# C++重写时调用父类实现
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2AA5E537-C27E-4AB9-9E1E-FF1910D582CD.png)

# C++虚析构函数的场景
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/964A7A2A-096D-45C7-BEAE-C20DBCEC682C.png)
C++里的析构函数和普通函数一样，需要父类申明为虚函数才能在多态的场景下根据类型去调用对应的析构函数。

# 纯虚函数
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5D8E5037-9F9F-4B15-B925-728DFA8582B9.png)
C++没有协议的概念，把包含纯虚函数（只有申明，没有实现的虚函数）的类看作协议（Swift）。

# C++多继承
## 多继承情况下内存布局
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9D625C4F-C3FB-4067-AAA0-1C85D2D5580F.png)内存布局中先继承的成员变量在前面。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1A439F67-42B1-4F20-B6D1-3DDC736E7046.png)
多个父类都有虚函数，那么内存布局里会产生多张虚表，重写后放置的是重写后的方法地址。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/00BE2986-3DB8-486E-B8C4-3EBC308DDF2B.png)
⚠️ 如果没有重写的情况，会放置父类的虚函数地址。

## 多继承体系下的构造函数调用
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/D8E421C2-1053-4808-8579-B102F3C12F7B.png)
依次通过初始化列表初始化各个父类。

## 多继承体系同名函数和成员变量
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/E784C8C4-5B68-4105-93E8-C3DD0CC9636B.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/41358D6F-2FB6-423C-AE28-7BC3F3EDA5A7.png)
通过指明的方式完成同名父类函数和成员变量的访问，并且会把同名的所有成员变量继承下来，内存布局顺序由继承顺序决定。

## 菱形继承的内存布局
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/C762F8DF-C056-4733-8D82-712848731E47.png)
2个age

## 虚继承解决菱形继承的原理
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/D29EEA18-A49E-4776-BE6D-850CA9474BBD.png)
通过虚继承解决菱形继承所带来的内存拷贝问题。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/27F17021-0AEE-4B9F-9F8D-0C85AA650DDB.png)

**理解虚继承**  
⚠️本质通过虚表来解决，如果是以虚继承的方式继承某个类，那么内存布局里会在前面插入4个字节存储一个虚表结构指针指向虚表的包装结构地址，该结构内存放2个东西，1个是真正的虚表指针和在本类起始地址的偏移量（相当于标记虚表指针在本内内存布局中的位置），1个是虚基类第一个成员变量与本类起始地址的偏移量（相当于标记虚继承过来的成员变量在本类内存布局中的位置）

⚠️子类菱形继承时，继承了几个虚继承的父类就会产生几张虚表，内存布局时会把虚继承过来的基类成员变量放在本类成员变量后面，通过虚表内的偏移去找。

## 多继承的应用场景
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/C973697E-0146-479F-9235-34F2D6126B5A.png)
类似遵循多个协议。。。。。。

# 静态成员变量和函数
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/F5E71DD9-745B-488C-823E-15361D1ACB46.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/798C8932-E9F1-4883-8502-BEC87BA679E9.png)
类似全局变量，可以通过对象访问。。。。。。必须在类外面初始化。。。。。。。。。。

## 单例场景
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/E4DB6B2E-2FF0-4939-A01C-C7CD257D3E58.png)
Delete只是回收对象的内存，此时ms_rocket指针依然有值，为防止野指针错误，应当手动置NULL。

更严谨的一种做法
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/07D1935B-813A-4F36-BAE6-BCAC9BDE4F97.png)
防止调用拷贝构造出Rocket对象，私有化赋值运算符防止赋值。


## C++ Delete误区
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/BB660702-AE62-4860-B51C-2E09D1CF4854.png)
Delete只是回收堆空间内存，回收不代表清空数据，只代表可以被重新使用。同时也不会清空指针。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/CABE8811-49AD-4102-966B-27366CB6EE29.png)
即使把指针清空，也不会清空堆空间的数据

# Const成员
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ABDF5713-9869-4A68-91FF-32C9AED234CF.png)

# 拷贝构造函数
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/679DDBE4-9395-4C75-A1AA-D5EFDAE34162.png)
如果不写拷贝构造函数，会默认生成一个拷贝构造函数，作用就是将所有成员变量进行拷贝赋值。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1515D5A3-107B-4173-938B-7346AAAFF3C2.png)
子类拷贝构造函数也可以调用父类的拷贝构造函数完成父类私有变量的初始化。

⚠️拷贝构造可以不用写，默认就相当于把对象内存空间的所有字节数据进行拷贝，（对于指针的拷贝属于浅拷贝，只拷贝了指针存储的地址）
⚠️拷贝构造需要写的场景是当有指针类型的成员变量时，希望进行深拷贝时。

![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/08E917AA-B007-46CE-8749-62FD0102B60C.png)
构造函数是在对象创建完后调用，car4和car3都是已经存在的对象，这里只是进行了拷贝赋值操作，既不会调用构造函数，也不会调用拷贝构造函数。
Car car3 = car2 创建了car对象，再把car2的内容拷贝给car3，会调用拷贝构造函数，实际上 Car car3 = car2 和 Car car2（car1）是完全等价的写法。

# 深拷贝和浅拷贝
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/BFDA1AA3-98D0-47C1-BAE1-E7155D485ED9.png)
* 浅拷贝时指针的拷贝，深拷贝是申请了一块新的内存区域再进行拷贝。
* 默认拷贝函数就是浅拷贝，当需要深拷贝时需要自定义拷贝函数。
* 需要深拷贝的场景是有指针类型的成员变量，需要每次初始化时，将指针类型的成员变量所指向的内存空间拷贝到新的内存空间。

⚠️所有语言的深浅拷贝基本都是针对于指针的拷贝来说。

## 例子1
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9E0EAEF7-AB56-443B-BBD0-37128EC89AB8.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/BFEE88D9-4008-4209-B9BF-1D38788B109C.png)
堆空间的car对象的指针类型成员m_name指向了栈空间的name数组（C语言数组名代表数组首地址）

⚠️堆空间指向栈空间是非常危险的，因为栈空间生命周期由系统管理，会被随时回收，会出现野指针的问题（指向一块已经释放的内存空间）

### 解决办法如下：
在初始化方法里进行深拷贝，将栈上的name数组拷贝到堆空间。
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/AE4D29DA-9E7F-4FD1-8DD6-F4FF4260D6B5.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/16B883A5-97A4-4E53-B55E-C4082A5DF921.png)

使用拷贝函数时也同理，自定义拷贝函数进行深拷贝。
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6BA4FBE9-48B1-48CF-8972-0B442750A667.png)

## 例子2
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8CCADCFD-B624-43D6-92AF-9D808A91DAA9.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/F566FBE5-42B4-4A77-A15A-B5240E5D7668.png)
第一个car是指针成员变量，第二个是car对象。
第一个情况进行浅拷贝，person1和person2的m_car指向同一个对象。
第二个person1和person2是2个不同的对象，因为m_car是成员对象，相当于person的内存区域里存储着person（也就是person此时占8个字节，分别是m_age和来自car对象的m_price）

⚠️：编译器默认浅拷贝操作简单理解就是说把那块内存空间所存储的东西进行了拷贝，存的是地址就拷贝地址，也就是指针的拷贝。如果本身像例2这种情况，m_car作为成员对象，其内存原本就在person的内存布局里，person的拷贝也会把car对象进行拷贝。

# 对象作为函数参数和返回值
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/F08FE0B7-8DB4-47E1-A3ED-CCC4E0A799FD.png)
函数传参相当于赋值，赋值在C++里就相当于拷贝构造。
上面这种会产生中间对象，相当于car1传进去进行了拷贝构造，C++里一般使用引用和指针传递。（也就是拷贝构造函数为什么必须要用引用的原因，否则会无休止的调用拷贝构造函数）
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/D79E7598-36C6-4193-8DDF-0FCBFDB7DACB.png)
⚠️使用对象类型作为参数和返回值会产生不必要的中间对象（匿名对象除外，匿名对象就是Car()这种），C++里一般使用引用或者指针。

# C++隐式构造
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/BB8295D2-B363-4757-A249-72AD63259F6B.png)

# C++生成默认构造的情况
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/C36CAA7B-F735-4E51-BF58-68BBED3475D6.png)
编译器不会为每一个类生成无参的构造函数，只有在一些特定情况下会生成（这种特定情况可以理解为创建完后有事干，也就是初始化一些东西，比如）
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/B935B8A5-0CEE-42F5-A3BD-5F1C385FC8A6.png)

# C++友元
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/948E7BFA-D5E6-4D27-8B95-F980D2D278AA.png)
本质是编译器特性

# C++内部类
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7D296A59-7E97-4DDD-8090-75A82429C103.png)
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/691FE68B-192A-4E42-A6F5-9FD65FBCB1A0.png)
实现和申明分开的情况，本质是编译器特性只是限制访问权限

# C++局部类
![](C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/38703D77-9629-477A-A22D-687959532E1B.png)