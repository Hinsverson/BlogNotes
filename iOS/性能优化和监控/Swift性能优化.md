# Swift性能优化
#iOS知识点/性能优化监控

[【基本功】深入剖析Swift性能优化 - 掘金](https://juejin.im/post/5bdbdc876fb9a049f36186c3#heading-13)

理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。可以从内存分配方式、引用计数维护、方法派发三个角度去衡量性能标准。

总结就是：Struct+POP思想+泛型特化+方法内联等

## 内存分配方式上
1. 基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于堆区。
2. 高级的数据结构，比如类，分配在堆区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为堆区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此也是一种性能消耗。
3. Class相比Struct需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。

优化点：推荐使用struct

## 引用计数
Swift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。

* Class在堆区分配内存，需要使用引用计数器进行内存管理。
* 基本类型的Struct在栈区分配内存，无引用计数管理。
* 包含强类型的Struct通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，维护成本更高，Class只会有一份。

优化点：使用struct不要包含指针对象

## Method Dispatch
Class默认使用Dynamic dispatch，因为在编译期几乎每个环节的信息都无法确定，所以阻碍了编译器的优化，比如inline和whole module inline。

优化点：使用Static dispatch代替Dynamic dispatch提升性能
* inheritance constraints继承约束 我们可以使用final关键字去修饰Class，以此生成的Final class，使用Static dispatch。
* access control访问控制 private关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行Static dispatch。

> 编译器可以通过whole module optimization检查继承关系，对某些没有标记final的类通过计算，如果能在编译期确定执行的方法，则使用Static dispatch。 Struct默认使用Static dispatch。  
>   
> Swift快于OC的一个关键是可以消解动态分派。  

# 动/静态方法派发
静态派发：
1. 编译完成后就已经确定，运行时直接跳转到方法实现。
2. Swift会自动对器进行可能的内联和其他优化。
动态派发：
1. 运行时在函数表里动态寻找方法的实现，然后跳转到对应方法的实现里去。
2. 阻止了Swift对其进行可能的内联和其他优化。

# 结构体的静态派发
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4EC5C14D-F051-446C-8674-45A94DAC425E.png)

# 类基于继承的多态性
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4114FFE8-8DC2-4544-9AC5-5D6948301B95.png)

## 通过引用语意实现的多态
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10540983-33DD-4189-80E7-4F53B04E9208.png)
数组中的元素实际类型可能不同

## 通过函数表实现的多态
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/187B0FFE-9332-4C7B-A4A9-07DFE72BE39E.png)
Line在堆空间的前8个字节（类似OC中的isa）指向Line的类型信息，包含了对应实例对象的函数表信息，通过去表里查找方法完成动态派发。

## 性能对比
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2B29032D-9846-4F12-8979-DC06C31645DF.png)
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/EE07D030-C234-4D39-BFD1-919504C5DF7A.png)
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/A1DF12D8-32A4-4A5A-BFAA-3B83DEBE3776.png)

# 协议的多态性（非继承和引用语义）
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/F4588F94-49AB-408D-8A71-199502DF35E3.png)
遵循相同协议的结构体也可以实现多态

## 协议通过PWT实现动态派发
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01021821-0D96-4CB7-A807-9D3BA80A81CB.png)

## PWT寻找方法的流程
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/60E4A19A-C132-4556-8029-D4CE99299A8E.png)

## 协议的内存布局（大小不定）
由于实现协议的类型可能不同，内存空间、初始化方法等都不相同。所以Swift引入了一个分布在栈上的容器概念来对协议进行内存布局，其中3个固定word大小存放属性，一个word放VWT，一个word放PWT。
*VWT：实例对象的初始化、复制、销毁相关方法表。*
*PWT：协议的动态方法派发表。*
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/EFFB98EC-B584-4039-8A55-6A70B060A050.png)

### 属性的存储
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/269DC7E6-5E65-49D7-ACF0-C660EAEAB62E.png)
小于3个word（1个在64位8个字节）直接存储在Value Buffer里。

![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/904040F0-D776-4243-AB4B-B5BFEF00A6DD.png)
大于3个word（1个在64位8个字节）则把属性存储在堆中，Value Buffer存储指向堆的地址。

### VWT的存储
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/EFB9161F-BE51-4323-94BD-8347DD915059.png)
1个word用来存放VWT的内存地址（里面有协议初始化、复制、销毁相关函数地址信息）

### PWT的存储
![](Swift%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/591DB702-2A12-46F8-89D4-2012F95D5CC4.png)
1个word用来存放PWT的内存地址（协议方法）



