# iOS 多线程基础
#iOS知识点/多线程

[iOS多线程全套：线程生命周期，多线程的四种解决方案，线程安全问题，GCD的使用，NSOperation的使用-CocoaChina_让移动开发更简单](http://www.cocoachina.com/cms/wap.php?action=article&id=19769&from=singlemessage&isappinstalled=0)
[iOS多线程与网络（1）—基本概念 - 简书](https://www.jianshu.com/p/1379629f7f21)
[iOS面试题－关于多线程 - 简书](https://www.jianshu.com/p/89b3edfb43ce)

# 基础概念
## 进程
是系统进行资源分配和调度的基本单位，是操作系统结构的基础，主要管理资源，可以理解成一个运行中的应用程序。

### 进程的几种状态和切换
![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/E91F6E8A-B6DD-4538-AD78-ECB2CE83D2A2.png)
1. 就绪状态
进程已获得除CPU外的所有必要资源，只等待CPU时的状态。一个系统会将多个处于就绪状态的进程排成一个就绪队列
2. 执行状态
进程已获CPU，正在执行。单处理机系统中，处于执行状态的进程只一个；多处理机系统中，有多个处于执行状态的进程
3. 阻塞状态
正在执行的进程由于某种原因而暂时无法继续执行，便放弃处理机而处于暂停状态，即进程执行受阻。（这种状态又称等待状态或封锁状态）

## 线程
是CPU调度和分派的基本单位，进程的基本执行单元，一个进程对应多个线程。

### 线程的几种状态
![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/71FA952B-CDEA-4FEF-8AD9-0FB925165157.png)

## 并发和并行
并发：一个CPU在多个线程间快速的切换执行
并行：多个CPU在同一时间互不干扰的同时执行多个线程

**并发是一种能力，处理多个任务的能力。并行是状态，多个任务同时执行的状态**

# 多线程
在同一时刻，一个CPU只能处理1条线程，但CPU可以在多条线程之间快速的切换，只要切换的足够快，就造成了多线程一同执行的假象

> 线程就像火车的一节车厢，进程则是火车。车厢（线程）离开火车（进程）是无法跑动的，而火车（进程）至少有一节车厢（主线程）。多线程可以看做多个车厢，它的出现是为了提高效率。  

## 多线程的原理
(1).同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
(2).多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）
(3).如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象

## 多线程的应用
*主线程的主要作用*
显示\刷新UI界面
处理UI事件（比如点击事件、滚动事件、拖拽事件等）
*主线程的使用注意*
别将比较耗时的操作放到主线程中
耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验
*将耗时操作放在子线程中执行，提高程序的执行效率*

## 多线程优缺点
### 优点
1. 能适当提高程序的执行效率
2. 能适当提高资源的利用率（CPU、内存利用率）

### 缺点
1. 创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1kb）、栈空间（子线程512KB、主线程1MB，也可以用 - setStackSize:设置，但是必须是4k的倍数，而且最小是16KB），创建线程大约需要90毫秒的创建时间
2. CPU线程切换其实也是小号算力资源的，所以线程不是越多越好。
3. 如果开启大量的线程，会降低程序的性能
4. 程序设计更加复杂：比如线程之间的通信、多线程的数据共享

# iOS多线程方案
![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/BA1904A1-C562-432E-8770-10810D3CBB6E.png)

## NSThread
## 实现原理
底层创建一个pthread线程，并通过performSelector消息机制实现任务的执行，performSelector依赖于Mac_port。

## 启动流程
![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/DDA0EC5C-F3F9-4FD4-83B7-E70DABC5E72C.png)

## 初始化方法的区别
![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/E7895131-C840-40DC-8BA3-5D1FD88356DA.png)


# 多线程的安全隐患和解决方案
![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/E832E5F3-05AB-4A9A-959A-36CFCC9B517C.png)
当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题（抢夺资源）。

![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/BA1AC7F4-FBF2-4B09-8D5F-9DD451FB149E.png)

![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/5F161575-34E1-407C-B080-403790FF0BAB.png)

## 解决方案原理（线程同步）
![](iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/50019A5E-72CF-45C7-BDBB-0C15D6CB1BF9.png)

[iOS中的线程同步和文件读写方案（GCD+锁）](bear://x-callback-url/open-note?id=F85DA747-F09E-46A8-9852-B5AC809F8893-2318-000262FDACFA0C35)

# 死锁产生的四个必要条件
[GCD的死锁](bear://x-callback-url/open-note?id=BF993B66-CC37-4FCB-B83C-33389FC0E2DA-19794-0000AE6F7B32565D)
1. 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；
2. 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
3. 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
4. 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

# iOS多线程间的通信方式
[iOS线程间通信总结 - 掘金](https://juejin.im/post/5eb68830e51d454dd9406de1)
1. NSObject的performSelector方法
2. 通过共享的进程内存并结合线程锁来控制数据同步
3. GCD
4. Mach port：向接收消息的线程对应的runloop中添加port，然后设置delelgate获取消息。
5. 传统的进程通信方式（管道、套接字、共享内存）（沙盒原因会有限制）

# iOS进程间通信方式
因为沙盒（sandbox）机制限制，所以常见的App间通信方式以及使用场景总结如下：
1. Port (local socket)：上层封装为NSMachPort，Foundation中层封装为CFMachPort，Core Foundation下层封装为Mach Ports，Mach内核层（线程、进程都可使用它进行通信），常见场景就是port消息和socket通信（iOS后台App网络处理只有600s）
2. URL Scheme：在2个App的info.plist里配置，通过openURL的方法跳转到App2，典型的使用场景就是各开放平台SDK的分享功能
3. Keychain：app密码的存储，常见的场景就是一些密码保存App。
4. UIPasteboard：读取剪切板内容而达到通信，常见就是淘宝跟微信/QQ的链接分享。
5. UIActivityViewController：常见分享
6. App Groups：同一个团队开发的多个应用之间直接数据共享。


