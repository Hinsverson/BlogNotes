# isa相关
#iOS知识点/Runtime

# isa指针
![](isa%E7%9B%B8%E5%85%B3/5B96A899-6279-4B85-BC99-C6A7957B11BD.png)
![](isa%E7%9B%B8%E5%85%B3/9982F462-AFDA-41CC-8FE1-FA2BC8F511D0.png)

**64位前**
这8个字节直接放的是class、或者Meta-class的内存地址（普通指针）
**64位后**
isa变成了一个共用体，用64位的内存空间存储着更多的东西，其中33位存放class、或者Meta-class的内存地址，其他位存放了一些其他信息（包含isa详解里的东西）

# isa的指向关系
![](isa%E7%9B%B8%E5%85%B3/CF74A28B-102F-45EB-8CCF-991135074ECD.png)

# 实例对象、类对象和元类对象的联系和区别
![](isa%E7%9B%B8%E5%85%B3/8B3ED982-1A45-410C-A95E-8D640DCAD08F.png)
1. 实例对象isa指向类对象
2. 类对象指isa向元类对象
3. 元类对象的isa指向元类的基类
4. 元类的基类的isa指向本身
5. 元类的基类的superClass指向类对象的元父类

**注意点：**
根元类的父类是根类对象意味着定义一个没有实现的类方法，如果类对象里面有同名方法，则会调用类对象里的实例方法。

# ARM64位之后isa优化原理
[C/C++ 中的位域与共用体 :: iBlog](https://kingcos.me/posts/2019/bit_field_union_in_cpp/)
1. 通过一个共用体成员（bits）共享一块内存，把需要存储的信息放在这个成员的不同位上，节省内存空间。
2. 使用信息掩码对这个共用体成员进行位运算，从而进行取值和赋值操作。
3. 再通过结构体的位域来增强可读性（实际并不做存储，只是标示了需要存储的信息和它在共用体内存中所占的位数）

## Union共用体概念
共用体表示内部的成员大家共用一块内存。

## Union共用体的大小
比一个union共用体内部只有一个char类型（1个字节）成员bits，那么这个共用体内存大小位1个字节，一共8位。可以用结构体位域标示希望用1位来存储一个Boo类型的信息，所以它最多能存储8个Boo类型的信息，可以根据实际需求，定义不同大小的共用体操作成员。

## 按位运算
按位&运算：大家都为1才是1
按位|运算：只要其中一个为1则就是1

按位运算取出特定的二进制位。
比如10010010，我想知道它的第四位是0还是1，这个时候可以用一个00010000掩码和10010010来做&运算，如果结果是00010000则代表第四位是1，如果结果是00000000则代表第四位是0.

按位运算设置特定的二进制位。
比如10010010，我想把它的第五位设置成1，这个时候可以用一个00001000掩码和10010010来做|运算。
比如10010010，我想把它的第四位设置成0，这个时候可以用一个11101111掩码和10010010来做按位&运算。

# isa取指向地址的原理
通过地址掩码和isa地址位进行&运算

举例：假如我想在1个字节的char上存储3个Bool类型的信息
![](isa%E7%9B%B8%E5%85%B3/584EF368-DEEA-47A4-8EAB-CEADBD0AA5DC.png)
宏定义为移位操作，是存储的信息取值和赋值的掩码（1<<2表示00000100）
