# 内存相关基础
#iOS知识点/内存相关

[swift之内存布局 - 简书](https://www.jianshu.com/p/d341974404a7)
[swift的指针介绍,指针的常用函数和使用 - 简书](https://www.jianshu.com/p/1b762bdaed75)
[Swift内存赋值探索一： 理解对象在内存中的存储状态 - 简书](https://www.jianshu.com/p/ba55eb9d8013)
[【基本功】深入剖析Swift性能优化 - 简书](https://www.jianshu.com/p/440d760a7392)
[Swift进阶之内存模型和方法调度 - Leo的专栏 - CSDN博客](https://blog.csdn.net/Hello_Hwc/article/details/53147910)

# 基本内存布局结构
![](%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/36EAA158-052F-4BC2-951F-5BBC0E98CC7F.png)

# 堆区和栈区的区别
* 分布方式：栈区由高到低连续分配，地址越来越小，堆区则相反。
* 速度上：栈的数据结构和CPU提供指令支持这2点决定了它的的速度更快，而堆区涉及到动态查找合适空间和寻址等调度开销速度上相比较慢点。
* 安全性：栈是线程安全的，堆则不是（每个线程独享一个栈，堆是对进程来说的，多条线程共享）
* 大小上：栈是一块空间较小，堆是内存中的另一块区域，空间比栈大的多。
* 创建管理：栈上的内存只由系统进行自动分配和管理，堆主要是成员进行分配。

# 堆和栈的实际意义和解决的问题
从汇编角度来讲首先汇编里面变量的概念几乎没有了，有的只是各种内存地址。访问一个变量就是靠地址，所以如果你不记住一个变量的地址，你就没办法去操作它。所以在大量变量的情况下就产生了一些地址管理的问题。所以以一种系统的方法管理内存就显得尤为重要。

1. 需要频繁访问，但是生命周期很短把它放在栈上。
2. 不需要太频繁的访问，但生命周期较长存储在堆上。

# iOS内存映射
![](%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/C1ECE243-F039-493F-9844-803F5AE92D01.png)
进程A和B都拥有1到4的虚拟内存。系统通过虚拟内存到物理内存的映射，让A和B都可以使用到物理内存。上图中物理内存是充足的，但是如果A占用了大部分内存，B想要使用物理内存的时候物理内存却不够该怎么办呢？在OSX上系统会将不活跃的内存块写入硬盘，一般称之为swapping out。iOS上则会通知App，让App清理内存，也就是我们熟知的Memory Warning。

> 我们向系统申请内存时，系统并不会给你返回物理内存的地址，而是给你一个虚拟内存地址。  
> 只有我们开始使用申请到的虚拟内存时，系统才会将虚拟地址映射到物理地址上，从而让程序使用真实的物理内存。  

# malloc 和 calloc
我们除了使用NSObject的alloc分配内存外，还可以使用c的函数malloc进行内存分配。malloc的内存分配当然也是先分配虚拟内存，然后使用的时候再映射到物理内存，不过malloc有一个缺陷，必须配合memset将内存区中所有的值设置为0。这样就导致了一个问题，malloc出一块内存区域时，系统并没有分配物理内存。然而，调用memset后，系统将会把malloc出的所有虚拟内存关联到物理内存上，因为你访问了所有内存区域。

> 苹果官方推荐使用calloc代替malloc，calloc返回的内存区域会自动清零，而且只有使用时才会关联到物理内存并清零。  




